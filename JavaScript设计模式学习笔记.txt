设计模式

--- 2014 04 02 ---
第一章 : 富有表现力的JavaScript

    1.1  JavaScript的灵活性

      长久以来，JavaScript都被当作是玩具语言，认为职业的程序员无需关注于此。其实很多时候我们并没有认识到
      他的全部能力和当今的编程世界的独特性，JavaScript是一种极富表现力的语言，它具有C语言家族所罕见的特性。

      这种语言允许你用各种方法完成同样的任务，还允许你在面向对象的编程过程中使用函数式的概念来丰富其实现方式，
      接下来解释并探究为什么该使用设计模式，以及它们在JavaScript程序设计的运用是如何使代码更高效，更易于处理。

      例如一个很常见的例子：动画的开始和结束:

        (1)
        /* Start and stop animation using function */

        function startAnimation() { ... }
        function stopAnimation()  { ... }

        //这种做法很简单，但是你无法创建可以保存状态并且具有一些仅对其内部状态进行操作的方法的动画对象。
        下面的代码定义了一个类，你可以用它来创建这种对象：

        (2)    
        /* Anim class */

        var Anim = function() {
            //...
        };

        Anim.prototype.start = function() {
            //...
        }; 

        Anim.prototype.stop = function() {
            //...
        };

        /* Usage */

        var myAnim = new Anim();
        myAnim.start();
        //...
        myAnim.stop();

        //上述代码定义了一个名为Anim的类，并把两个方法赋给了该类的prototype属性。(更多prototype详见第三章)


        (3):较为传统的方式
        //将方法定义在class内部
        /* Anim class, with a slightly different syntax for declaring methods. */

        var Anim = function() {
            //...
        };

        Anim.prototype = {
            start : function () { //... },
            stop  : fucntion () { //... }
        };

        (4)
        /* Add a method to the Function Object that can be used to declare methods. */

        Function.prototype.method = function(name, fn) {
            this.prototype[name] = fn;
        };

        /* Anim class. with method created using a convenience method. */

        var Anim = function() { //... };

        Anim.method('start', function() {
            //...
        });

        Anim.method('stop', function() {
            //...
        });

        (5)
        /* Same as the four , but chainable */

        Function.prototype.method = function(name, fn) { 
            this.prototype[name] = fn;
            return this;
        };

        /* Usage */

        var Anim = function() {
            //...
        };

        Anim.
            method('start', function() {
                //...
            }).
            method('stop', function() {
                //...
            });

        小节:同一个任务的5种实现方法，我们可以基于自己的编程风格，技术背景选择合适的顺手的进行工作，
        当然，不同的代码风格在篇幅、编码效率和执行性能方面各有其特点，后续将逐步介绍！

    1.2  弱类型语言        

        有三种原始类型：布尔型，字符串，数值型
        配合复合数据类型（数组等）
        最后还有空类型和未定义类型

        原始数据类型按值传送而其他类型按引用传送！！！！！！！！！

        类型转化小技巧：toString方法可以把数值类型或布尔值转换为字符串，parseInt、parseFloat可以把字符串
        转换为数值，双重"非"操作可以把字符串或数值转变为布尔值： var bool = !!num;

        弱类型的变量带来了极大的灵活性，JavaScript会根据需要进行类型转换，所以说省去了类型出错的麻烦

    1.3  函数是一等对象

        在JavaScript中函数是一等对象，他们可以存储变量，可以参与构造，可以作为参数传递给其他函数，可以作为
        返回值传递给其他函数，还可以在运行时进行构造。在与函数打交道时，这些特性带来了极大的灵活性和极强的
        表达能力，正是这些构成了构建传统的面向对象框架的基础！

        例如：匿名立即执行函数
            /* An anonymous function, executed immediately */

            (function(num) {
                var foo = 10;
                var bar = 2;
                alert(foo * bar * num); // 10*2*10 = 200
            })(a = 10);

            (function(foo, bar) {
                alert(foo * bar);
            })(10, 2)

        JavaScript的无法形成天然的私有变量，但不代表没办法，JavaScript具有函数级的作用域，这意味着定义在函数
        内部的变量在函数的外部无法被访问到，JavaScript的作用域又是词法性质的（lexically scoped）。这意味着
        函数运行在定义它的作用域中而非调用它的作用域中，把这两个因素结合起来，就能通过把变量包裹在匿名函数中
        而对其加以保护，创建私有变量。

        /* An anonymous function used as a closure */

        var baz; //此处可省略

        (function() {
            var foo = 10;
            var bar = 2;
            /* window.baz */ 
            baz = function() { //没有var声明的变量即为全局变量 如果var baz...则外部无法访问，依赖曝光到全局
                return alert(foo * bar);
            }; 
        })();
        baz(); 

    1.4  对象的易变性
        在JavaScript中，一切都是对象(除了那三种原始数据类型，即便是这些类型，在必要的时也会被自动包装为对象)
        所有对象都是易变的(mutable)。这意味着你可以使用一些在其他语言中所不允许的技术，例如为对象添加属性：
        function displayError(message) {
            displayError.numTimesExecuted++;
            alert(message);
        };
        displayError.numTimesExecuted = 0;
        //意味着你可以对先前定义的类和实例化的对象的属性进行自由的修改：

        /* Class Person */

        function(name, age) {
            this.name = name;
            this.age  = age;
        }

        Person.prototype = {
            getName : function() {
                return this.name;
            },
            getAge  : function() {
                return this.age;
            }
        }

        /* Instantiate the class */

        var Pr = new Person('pengrui' , 21);
        var Xx = new Person('xiaoxuan', 21);

        /* Modify the class */

        Person.prototype.getGreeting = function() {
            return 'Hi' + this.getName() + '!';
        };

        /* Modify a specific instance */

        Pr.displayGreeting = function() {
            alert(this.getGreeting());
        }
        //getGreeting方法在实例化了两个对象后再添加，这就得益于原型链继承机制，而且Pr对象还多了个
        displayGreeting方法，而别的实例却没有！

        对象的易变性相关的还有一个内省(introspection)的概念，你可以在运行时检查对象所具有的属性和方法
        还可以使用这些信息动态实例化类和执行其方法(这种技术叫做反射reflection),甚至不需要在开发时知道
        他们的名称，这些技术在动态脚本编程中发挥着重要作用，而静态语言如C++则显然不能。

        JavaScript的大多数仿照传统面向对象的特性都依赖对象的易变性和反射，如果习惯了C++和Java，则很奇怪
        ，因为这些语言中，不能对已经实例化的对象进行扩展，也不能对已经建立好的类进行修改，这使得JS成为了
        一种强力武器，当然也有其坏处，运行时可以修改导致原来写的类及其方法并不能保证未来完好性，这是JS
        很少进行类型检查的原因之一，这些问题还将在"鸭式辨型"(duck typing)和接口检查时进行探讨。

    1.5  继承
        天然的是基于原型链式的继承，强于类继承，所以可以模仿它。后续重点讨论这部分！

    1.6  JavaScript中的设计模式
        设计模式就是为了解决下列问题：
        (1)  可维护性
        (2)  沟通
        (3)  性能

        不使用设计模式的理由:
        (1)  复杂性
        (2)  性能:获得可维护性的同时，大部分的设计模式都会或多或少的拖累性能。

--- 2014 04 03 ---
第二章 : 接口
    2.1  什么是接口？
        接口提供了一种用以说明一个对象应该具有哪些方法的手段。具有一定的语义性或者至少暗示了这些方法的语义
        有了这个工具，你就能按对象提供的特性进行分组，例如一批对象彼此存在着极大的差异，但是他们都实现了一个
        Comparable接口，那么在Object.compare(anotherObject)方法中就可以互换使用这些对象，你还可以使用接口开
        发不同的类的共同性。

        接口之利：
            既定的一批接口具有自我描述性，并能够进行代码重用，接口可以告诉程序员一个类实现了哪些方法，从而帮助
        其使用这个类，如果你熟悉一个特定的接口，那么就已经知道了如何使用任何实现了这个接口的类，从而更有
        可能重用现有的类。
            接口还有助于稳定不同的类之间的通信方式，如果事先知道了接口，你就能减少在集成两个对象的过程中出现的
        问题，借助于它，你可以事先就说明你希望一个类有哪些特性和操作，一个程序员可以针对需要的类定义一个
        接口，并把它转交给另一个程序员。第二个程序员可以随心所欲的编写自己的代码，只要他定义的类实现了那个
        接口。这种方式在大型项目中极其有用。
            测试和调试因此变得更轻松。在JavaScript这种弱类型语言中，类型不匹配的错误很难追踪，使用接口可以然这
        种错误的查找更方便一点，因为此时如果一个对象不像所要求的类型，或者没有实现必要的方法，那么你就会得
        到错误信息，错误被限制在了方法内而非对象的构成中。
            接口还能让代码变得稳固，因为对接口的任何改变将在所有实现了它的类中体现，如果接口添加了一个操作，
        而实现了它的类中并没有添加此方法，你肯定会立即看到一个错误！

        接口之弊：此处指JS接口
            接口一定程度上强化了类型的作用，这降低了语言的灵活性。
            接口在JavaScript中没有内置支持，而试图模仿其他语言内置的功能总会有一些风险，JavaScript中没有
        Interface这个关键词，因此你用什么方法实现接口总与C++/Java这些语言大相径庭，加大了难度
            在JavaScript中实现接口的方法都会对性能造成影响，在某种程度上归咎于额外的方法开销，我们的实现
        方式中使用了两个for循环遍历所需要的每个接口中的每个方法，性能会受影响。
            最重要的一点，非原生的就无法保证其他程序员遵守了你设计的接口，其他语言内置的接口概念会确保该类
        实现这个接口。编码规范和辅助类或许可以帮助我们，但终究还是要靠自觉且强制性无法保证，失去接口价值!

    2.2  几种其他语言的经典接口使用范例
    
    2.3  在JavaScript中模仿接口

      (1)  注释描述法 ： 最简单，但效果是最差的，这种方法模拟其他面向对象语言中的interface和implements关键字

        /*
    
        interface Composite {
            function add(child);
            function remove(child);
            function getChild(index);
        }

        interface FormItem {
            function save();
        }

        */

        var CompositeForm = function(id, method, action) {
            //...
        };

        //Implement the Composite interface

        Composite.prototype.add = function() { //... };
        Composite.prototype.remove = function() { //... };
        Composite.prototype.getChild = function() { //... };

        //Implement the FormItem interface

        CompositeForm.prototype.save = function() { //... };

        /*
         *  这种方法并不好，它并没有确保CompositeForm真正实现了正确的方法集而且也没有错误抛出，说到底还是程序文档
         *  范畴
        */

        (2)  用属性检查模仿接口

        /*  这种方法更严谨一点，所有类都明确声明了自己实现了哪些接口，
         *  哪些想与这个类打交道的对象可以针对这些声明进行检查。哪些
         *  接口自身仍然是注释，但现在你可以通过检查一个属性得知某个类自称实现了什么接口 
         */

        /*
        interface Composite {
            function add(child);
            function remove(child);
            function getChild(index);
        }

        interface FormItem {
            function save();
        }
        */

        var CompositeForm = function(id, method, action) {
            this.implementsInterfaces = ['Composite', 'FormItem']; //数组存储宣称要实现的接口
            //...
        };

        //...

        fucntion addForm(formInstance) {
            if(!implements(formInstance, 'Composite', 'FormItem')) {
                throw new Error("Object does not implement a required interface");
            }
            //...
        }

        // The implements function, which checks to see if an object declares that it
        // implements the required interface.

        function implements(object) {
            for(var i = 1; i < arguments.length; i++) {
                var interfaceName = arguments[i];
                var interfaceFound = false;
                for(var j = 0; j < object.implementsInterfaces.length; j++) {
                    if(object.implementsInterface[j] == interfaceName) {
                        interfaceFound = true;
                        break;
                    }
                }
                if(!interfaceFound) {
                    return false; //An interface was not found
                }
            }
            return true; //All interfaces were found.
        }  

        (3)  鸭式辨型模仿接口

        /* 类声明了自己支持哪些接口并不重要，只要它具有这些接口中的方法就行。
        *  这个方法背后的观点很简单，如果对象具有与接口定义相同方法名的所有方法
        *  那么就可以认为它实现了这个接口，下面构造一个辅助函数来确保对象具有必须的方法 
        */

        //Interfaces

        var Composite = new Interface('Composite', ['add', 'remove', 'getChild']);
        var FormItem  = new Interface('FormItem', ['save']);

        //CompositeForm class

        var CompositeForm = function(id, method, action) {
        //...
        };

        //...

        function addForm(formInstance) {
            ensureImplements(formInstance, Composite, FormItem);
            //this function will throw an error if a required method is not implemented.
        }

        (4)  集百家之长实现接口！！！*********************！！！

        本法综合采用第一种和第三种方法，用注释声明类支持的接口，从而提高代码可重用性及其文档的完善性。
        我们还辅助类Interface及其类方法Interface.ensureImplements来对对象实现的方法显式检查。如果对象
        未能通过检查，则返回错误信息！

        //Interface类
        //下面是本书中使用的Interface类的定义：包括对参数及其类型进行了强制严格的检查！！！
        //如果没有错误被抛出则可以确定接口得到了正确的声明和实现

        //Constructor
        var Interface = function(name, methods) {
            if(arguments.length != 2) {
                throw new Error("Interface constructor called with" + 
                arguments.length + "arguments, but expected exactly 2");
            }

            this.name = name;
            this.methods = [];
            for(var i = 0, len = methods.length; i < len; i++) {
                if(typeof methods[i] !== "string") {
                    throw new Error("Interface constructor expects method names to be passed in as a string!");
                }
                this.methods.push(methods[i]);
            }
        };

        //Static class method
        Interface.ensureImplements = function(object) {
            if(arguments.length < 2) {
                throw new Error("Function Interface.ensureImplements called with" + arguments.length + 
                "arguments, but expected at least 2.");
            }

            for(var i = 1, len = arguments.length; i < len; i++) {
                var interface = arguments[i];
                if(interface.constructor != Interface) {
                    throw new Error("Function Interface.ensureImplements expected arguments two and above"
                    + " to be instance of Interface.");
                }

                for(var j = 0, methodsLen = interface.methods.length; j < methodLen; j++) {
                    var method = interface.methods[j];
                    if(!object[method] || typeof object[method] !== "function") {
                        throw new Error("Function Interface.ensureImplements: object does not implement the "
                    + interface.name + " interface. Method " + method + "was not found.");
                    }
                }
            }
        };

    2.4  如上

    2.5  Interface类的使用场景：
        在开发的过程中，如果API发生了变化，只要新的API实现了同样的接口，它就能天衣无缝的替换原有API。现在
        的因特网上你无法控制的代码情况越来越多，虽然他们来源可靠，可是还是需要谨慎的使用，一种应对方法为为
        每一个依赖的API创建一个Interface对象，然后对每一个对象进行检查，以确保正确实现了那些接口：

        var DynamicMap = new Interface('DynamicMap', ['centerOnPoint', 'zoom', 'draw']);

        function displayRoute(mapInstance) {
            Interface.ensureImplements(mapInstance, DynamicMap);
            mapInstance.centerOnPoint(12, 34);
            mapInstance.zoom(5);
            mapInstance.draw();
            //...
        }

        这个例子中，Interface对象很好的验证了API的参数，确保了系统的稳定性和安全性。

    2.6  依赖接口的设计模式  以后细说...
        工厂模式
        组合模式
        装饰着模式
        命令模式  

--- 2014 04 04 ---
第三章 : 封装与信息隐藏
    3.1  信息隐藏原则  封装
        是面向对象对象编程的根本，它把实现的具体细节隐藏而暴露出一些语义化的接口供开发者使用，不必关系实现细节。
        信息隐藏是目的，封装是手段
        接口扮演的角色：接口提供了一份记载着可供公众访问的方法的契约，它定义了两个对象间可以具有的关系，只要接口
        不变，这个关系的双方都是可替换的，不一定非得使用第二章定义的那样的严格接口，但大多数情况下，你将发现对
        可以使用的方法加以记载是很有好处，不是有了接口就万事大吉了，你应该避免公开未定义于接口中的方法，总之，
        暴露出可供使用的方法，并且不让其他开发者对此对象未公开的方法产生依赖，造成不良后果。

    3.2   创建对象的基本模式
        (1)  门户大开型对象
        var Book = function(isbn, title, author) {
            if(isbn == undefined) throw new Error("Book constructor requires an isbn.");
            this.isbn   = isbn;
            this.title  = title || "No title specified";
            this.author = author || "No author specified";
        } 

        Book.prototype.display = function() {
            //...
        };

        //在构造器中检查isbn，如果没有提供ISBN，将会抛出一个错误，这是因为display方法要求书籍对象有一个准确的ISBN
        ，否则就找不到相对应的图片，也不能生成一个用于购买图书的链接，title和author是可选的。咋一看这符合要求，
        不过最大的问题就是你无法检验ISBN数据的完整性，而不完整的ISBN有可能使display失灵，破坏了契约。如果Book对象
        创建时没有抛出任何错误，那么display方法就应该正常工作。下面的版本强化了检验ISBN。

        (2)  严格一些的门户大开型
        var Book = function(isbn, title, author) {
            if(!this.checkIsbn(isbn)) throw new Error("Book: Invalid ISBN.");
            this.isbn   = isbn;
            this.title  = title || "No title specified";
            this.author = author || "No author specified";
        }

        Book.prototype = {
            checkIsbn : function(isbn) {
                if(isbn == undefined || typeof isbn != 'string') { return false; }

                isbn = isbn.replace(/-/, ''); //remove dashes.
                if(isbn.length != 10 && isbn.length != 13) { return false; }

                var sum = 0;
                if(isbn.length === 10) { //10 digit ISBN
                    if(!isbn.match(/^\d{9}/)) { //Ensure characters 1 through 9 are digit
                        return false;
                    }  

                    for(var i = 0; i < 9; i++) {
                        sum += isbn.charAt(i) * (10 -i);
                    }
                    var checksum = sum%11;
                    if(checksum === 10) checksum = 'X';
                    if(isbn.charAt(9) != checksum) { return false; }

                } else {
                    if(!isbn.match(/^/d{12}/)) { //Ensure characters 1 through 12 are digit 
                        return false; 
                    }
                    for(var i = 0; i < 12; i++) {
                        sum += isbn.charAt(i) * ( ( i % 2 ===0 ) ? 1 : 3 );
                    }
                    var checksum = sum % 10;
                    if(isbn.charAt(12) != checksum) { return false; }
                }
                return true;
            },

            display : function() { 
                //... 
            }
        };

        /*  加入了一个checkIsbn方法，确保isbn为准确的
         *  Book.prototype被设置为字面量，这样就可以多个非法写在{}内。
         *  但是这样看起来真的万无一失，可是，实例化书籍对象后却可以修改其isbn属性，这种毫无控制不符合软件工程
         *  下面为Book对象添加getter和setter方法，用来把新值赋给属性之前进行各种检验
        */

        (3)  加入取值器和赋值器之后的新版Book对象

        var Publication = new Interface('Publication', ['getIsbn', 'setIsbn', 'getTitle', 'setTitle', 
          'getAuthor', 'setAuthor', 'display']);

        var Book = function(isbn, title, author) { //implements Publication
            this.setIsbn(isbn);
            this.setTitle(title);
            this.setAuthor(author);
        }

        Book.prototype = {
            checkIsbn : function(isbn) {
                //...
            },
            getIsbn   : function() {
                return this.isbn;
            },
            setIsbn   : function(isbn) {
                if(!this.checkIsbn(isbn)) throw new Error("Book: Invalid ISBN.");
                this.isbn = isbn;
            },
            getTitle  : function() {
                return this.title;
            },
            setTitle  : function(title) {
                this.title = title || "No title specified";
            },
            getAuthor : function() {
                return this.author;
            },
            setAuthor : function(author) {
                this.author = author || "No author specified";
            },

            display   : function() {
                //...
            }
        };
        //注意，这是使用门户大开型对象创建方式所能得到的最好结果了，里面包含了一个明确的定义的接口、一些对数据
        //具有保护作用的取值器和赋值器，以及一些有效性检验方法，不过不能真正的严格保护内部数据，但是使用方便。

      (4) 用命名规范区别私用成员创建对象
        var Book = function(isbn, title, author) {
            this.setIsbn(isbn);
            this.setTitle(title);
            this.setAuthor(author);
        }

        Book.prototype = {
            checkIsbn : function(isbn) {
                //...
            },
            getIsnb   : function() {
                return this._isbn;
            },
            setIsbn   : function() {
                if(!this.checkIsbn(isbn)) throw new Error("Book: Invalid ISBN.");
                this._isbn = isbn;
            },
            getTitle  : function() {
                return this._title;
            },
            setTitle  : function(title) {
                this._title = title || "No title spectified";
            },
            getAuthor : function() {
                return this._author;
            },
            setAuthor : function(author) {
                this._author = author || "No author specified";
            },

            display   : function() {
                //...
            }
        };
        //在这个例子中，所有的属性都已经重新命名，每个属性的名称前都加了一个下划线，表示它是私有成员变量
        //下划线标明归根到底还是一种约定，需要在大家都遵守的情况下得到很好的使用。

      (5)  作用域、嵌套函数和闭包来创建真正的私有成员

        接下来讨论真正的私用属性，当前先要说下JavaScript中的作用域。
        在JavaScript中只有函数有作用域，也就是所在函数内部声明的变量在函数外部无法访问，例如：

        function foo() {
            var a = 10;

            function bar() {
                a *= 2;
            }

            bar();
            return a;
        }

        var baz = foo(); //baz is a reference to function bar.
        //baz(); //return 20
        //baz(); //error Uncaught TypeError: Property 'baz' of object [object Window] is not a function 
        //baz(); //error Uncaught TypeError: Property 'baz' of object [object Window] is not a function 

        function a() {
            //return alert("a");
            return function() { alert("a"); }
        }
        var b = a();
        b(); // alert("a");
        b(); //error
        b(); //error 

        //也就是说定义一个函数并赋给一个引用，引用不可多次调用，因为一次调用后元函数就销毁了，被回收了。

        //但是...

        function foo() {
            var a = 10;

            function bar() {
                a *= 2;
                return a;
            }

            return bar;
        }

        var baz = foo(); //baz is a reference to function bar.
        baz(); //return 20
        baz(); //return 40
        baz(); //return 80

        var blat = foo(); //blat is another reference of function bar.
        blat(); //20 because blat is a new copy of bar,have nothing to do with the baz 
        blat(); //40
        blat(); //80

        //这段代码最大的启示是：证明了JavaScript的作用域是此法性质的，即函数是运行在定义它的作用域中
        //而非调用它的作用域中(如果是调用作用域，a就会被保存，因为还是foo())，而且告诉了我们最简单的一个
        //创建闭包的方法，返回一个function。
        *********************  返回一个内嵌函数是最简单的构建闭包的方法  *********************

      用闭包实现私有成员：(适用于真正需要私有成员的地方)
        var Book = function(newIsbn, newTitle, newAuthor) {

            //private attributes
            var isbn, title, author;

            //private methods
            function checkIsbn(isbn) {
                //...
            }

            //privileged methods
            this.getIsbn = function() {
                return isbn;
            };
            this.setIsbn = function(newIsbn) {
                if(!checkIsbn(newIsbn)) throw new Error("Book: invalid ISBN.");
                isbn = newIsbn;
            };
            this.getTitle = function() {
                return title;
            };
            this.setTitle = function(newTitle) {
                title = newTitle || "No title specified.";
            };
            this.getAuthor  function() {
                return author;
            };
            this.setAuthor = function(newAuthor) {
                author = newAuthor || "No author sepctified.";
            };

            //constructor code
            this.setIsbn(newIsbn);
            this.setTitle(newTitle);
            this.setAuthor(newAuthor);
        };

        //Public, non-privileged methods.
        Book.prototype = {
            display : function() {
                //...
            }
        };

        /*
         *  这与我们先前创建对象的方式有什么不同那？
         *  在本例中，我们只使用var创建变量，还有checkIsbn方法，这就意味着这些都只存在于Book构造器中
         *  需要访问这些变量的方法称为特权方法，因为他们虽然是public的，却肩负访问私有变量的重任
         *  这种对象创建方式解决了原来创建对象的其他模式中的所有问题，但是这种方式会为每一个对象
         *  创建一份，耗费了更多内存并且在派生中也更困难，被称为"继承破坏封装"，适用于真正需要私有成员的地方
        */

    3.3  更多高级对象的创建模式
      (6)  静态方法和属性

        添加了静态属性和方法的Book类

        var Book = (function() {

            //private static attributes.
            var numOfBooks = 0;

            //private static method.
            function checkIsbn(isbn) {
                //...
            }
 
            //return the constructor.
            return function(newIsbn, newTitle, newAuthor) {
                //private attributes.
                var isbn, title, author;

                //privileged methods
                this.getIsbn = function() {
                    return isbn;
                };
                this.setIsbn = function(newIsbn) {
                    if(!checkIsbn(newIsbn)) throw new Error("Book: invalid ISBN.");
                    isbn = newIsbn;
                };
                this.getTitle = function() {
                    return title;
                };
                this.setTitle = function(newTitle) {
                    title = newTitle || "No title specified.";
                };
                this.getAuthor  function() {
                    return author;
                };
                this.setAuthor = function(newAuthor) {
                    author = newAuthor || "No author sepctified.";
                };

                //constructor code
                numOfBooks++; //  keep track of how many books have been instantiated
                              //  with the private static attribute.
                if(numOfBooks > 50) 
                    throw new Error('Book: Only 50 instances of Book can be created');

                this.setIsbn(newIsbn);
                this.setTitle(newTitle);
                this.setAuthor(newAuthor);                  
            }
        })();

        //Public, non-privileged methods.
        Book.prototype = {
            display : function() {
                //...
            }
        };

        /*
         *  这里和上面的最大区别就是构造器从普通函数变成了一个内嵌函数，并且被作为函数的返回值赋给了
         *  变量Book，这就创建了闭包，你可以把静态的私用成员声明在里面，位于外层的函数声明之后的一对
         *  空括号很重要，作用是代码一载入就执行，调用这个内层函数，外层函数只是用来创建一个闭包用来
         *  存放静态私用成员的闭包。numOfBooks这个静态属性控制Book的实例化的个数限制在不超过50个
        */

        常量  
        
        class.getUPPER_BOUND();
        为了实现这个取值器，需要使用我们还未讲过的特权静态方法

        var Class = (function() {
            //Costants ( create as private static attributes )
            var UPPER_BOUND = 100;
            //Constructor
            var ctor = function(constructorArgument) {
                //...
            };
            //Privileged static method.
            ctor.getUPPER_BOUND = function() {
                return UPPER_BOUND;
            };
            //...
            //return the constructor
            return ctor;
        })();

        //多个常量，通用取值器方法
        var Class = (function() {
            //Private static attributes.
            var constants = {
                UPPER_BOUND : 100,
                LOWER_BOUND : -100
            };
            //Constructor
            var ctor = function() {
                //...
            };
            //Privileged static method
            ctor.getConstants = function(name) {
                return constants[name];
            };
            //...

            return ctor;
        })();

        /* Usage */
        Class.getConstants('UPPER_BOUND');

        单体和对象工厂  后续详细讲

    3.4  封装之利 ...
    3.5  封装之弊 ...   
         
    3.6  小节：
        本章讨论了信息隐藏的概念以及如何用封装这种手段实现它。因为JavaScript没有对封装提供内置的支持，
      所以实现必须依靠一些其他的技术，如果能够确信其他程序员只会使用接口中规定的方法，或者并非迫切的
      需要保持内部数据的完整性，那就可以使用门户大开型的创建方式，命名规范可以用来引导其他程序员，但
      非强制，如果需要实现真正的私用成员，那就是用闭包吧，此外，关注一下JavaScript的作用域的特点。

--- 2014 04 08 - 2014 04 09 ---
第四章 : 继承 

    引言:
      在JavaScript中继承是个非常复杂的概念，比其他任何面向对象语言都复杂，在大多数语言中，继承一个
    类只需要一个关键字就够了，但是JavaScript想要传承一个公用成员就需要采取一系列的措施，而且其具有
    特色的基于原型链的继承方式也可以让我们既能经典继承，又可以更微妙的继承。

    4.1  为什么需要继承
        在设计类的时候，我们希望减少代码的重复性，并且尽量弱化对象之间的耦合，比如复制代码到各个地方
        也可以实现代码复用，但是一旦业务修改，我们需要手动的一处一处的修改，假使我们有一个方法类，那么
        只需要修改一个地方就可以了。当然，这只是继承的最简单的好处。

    4.2  类式继承
        /* class Person */

        function Person(name) { //创建构造函数，惯例其名称就是类名
            this.name = name;
        }

        Person.prototype.getName = function() { //类的方法被添加到其prototype对象中
            return this.name;
        }

        var reader = new Person('Pengrui'); //创建类的实例就只需一个new关键字
        reader.getName();

        /* 创建Author类继承Person */

        /* Class Author */

        function Author(name, books) {
            Person.call(this, name); //Call the superclass's constructor in the scope of this
            this.books = books; //Add an attribute to Author
        }

        Author.prototype = new Person(); //Set up the prototype chain
        Author.prototype.constructor = Author; //Set the constructor attribute to Author
        Author.prototype.getBooks = function() { //Add a method to Author
            return this.books;
        };

      4.2.2 自制工具函数 extends
        /* Extend function */

        function extend(subClass, superClass) {
            var F = function() {}; 
            F.prototype = superClass.prototype;
            subClass.prototype = new F();
            subClass.prototype.constructor = subClass; //重定向子类Constructor
        }
        //改进之举：设置空函数，并将用它创建的一个对象实例插入原型链中，避免创建超类的实例，因为它可能会很庞大，
        而且有时候超类的构造函数有一些副作用，或者会执行一些需要进行大量工作的计算任务。

        /* class Person */

        function Person(name) {
            this.name = name;
        }

        Person.prototype.getName = function() {
            return this.name;
        }

        /* Class Author */

        function Author() {
            Person.call(this, name); //bad Person was fixed here. not flexiable
            this.books = books;
        }
        extends(Author, Person); //Author extends Person

        Author.prototype.getBooks = function() {
            return this.books;
        };

        /* Extend function, improved. */
    
        function extend(subClass, superClass) {
            var F = function() {};
            F.prototype = superClass.prototype;
            subClass.prototype = new F();
            subClass.prototype.constructor = subClass;

            subClass.superClass = superClass.prototype;
            if(superClass.prototype.constructor == Object.prototype.constructor) {
                superClass.prototype.constructor = superClass;
            }
        }
        //提供了superClass属性，这个属性可以用来弱化Author与Person之间的耦合，该函数的前面4行与前一版本的
        相同，最后三行则用代码用来确保超类的constructor属性已被正确设置(即使超类就是Object类本身)，在用新的
        superClass类属性调用超类的构造函数时这个问题很重要：
        /* Class Author */

        function Author(name, books) {
            Author.superclass.constructor.call(this, name);
            this.books = books;
        }
        extend(Author, Person);

        Author.prototype.getBooks = function() {
            return this.books;
        };
        有了superclass属性，就可以直接调用超类中的方法。这在既要重定义超类的某个方法而又想访问其在超类中
        的实现时可以派上用场。例如，为了用了一个新的getName方法重定义Person类中的同名方法，你可以先用
        Author.superclass.getName获得作者的名字，然后在此基础上添加其他信息：
            Author.prototype.getName = function() {
                var name = Author.superclass.getName().call(this);
                return name + ',Author of ' + this.getBooks().join(', ');
            };

    4.3  原型式继承
    
        /* Person prototype Object */

        var Person = {
            name    : 'default name',
            getName : function() {
                return this.name;
            }
        };

        var reader = clone(Person); //创建一个空对象，且原型对象被设置为Person
        console.log(reader.getName());
        reader.name = 'xiaoxuan';
        console.log(reader.getName());

        /* Author prototype Object */

        var Author = clone(Person);
        Author.books = []; //default value
        Author.getBooks = function() {
            return this.books;
        };

      4.3.1  对继承而来的成员的读和写的不对称性
        如果还未对子对象设置值的话，那么
            读出的值为原型对象的初值
            写入却是直接对子对象本身
        这也就是为什么总是应该对引用传递的属性创建新副本，通常是创建空字面量
        相关的用hasOwnProperty方法来区分对象的实际成员和它继承而来的成员

        又比如：一个对象本身就存在子对象，例如
        var CompoundObject = {
            string1 : 'default value',
            childObject : {
                bool : true,
                num  : 10
            }
        };
        var compoundObjectClone = clone(CompoundObject);

        //很可能会改变内部值 Bad!!!

        /* 此问题的最佳实践 */

        var CompoundObject = {};
        CompoundObject.string1 = 'default value';
        CompoundObject.createChildObject = function() {
            return {
                bool : true,
                num  : 10
            }
        };
        compoundObject.childObject = CompoundObject.createChildObject();

        var compoundObjectClone = clone(CompoundObject);
        compoundObjectClone.childObject = CompoundObject.createChildObject();
        compoundObjectClone.childObject.num = 5;

        /* 上述使用的工具函数clone()闪亮登场 */

        function clone(object) {
            function F() {}
            F.prototype = object;
            return new F; //等价于 return new F();
        }
        //首先创建了一个空函数F，然后将prototype属相设置为参数object传入的原型对象，prototype就是用来指向
        原型对象的，通过原型链机制，它提供了所有继承而来的成员的链接，该函数最后通过把new运算符作用于F创建出
        一个新对象，然后把这个对象作为返回值返回，函数所返回的这个克隆结果是一个以给定对象为原型对象的空对象。

    4.4  类式继承和原型继承的对比
        大多数人对类式继承更加熟悉这是不争的事实，所以如果设计一个供大多数人使用的API或者和不熟悉原型继承的
        人合作，那么最好使用类是继承。但是，原型继承自有其优势，比如更加节省内存，除非你为每个克隆的对象设置
        了属性和方法，克隆对象们总是共享同一份实例，而且通过工具函数clone()，整个继承过程更加简单，最后，任何
        高级JavaScript程序员最终都必须了解并且熟练使用原型继承及其机制！

    4.5  继承与封装
        此处不再赘述...

    4.6  掺元素:不必每个类都继承一个包含常用方法的类，只需将其共享即可，这样也实现了多继承（多个父类）  
    
        /* Mixin class */

        var Mixin = function() {};
        Mixin.prototype = {
            serialize : function() {
                var output = [];
                for(key in this) {
                    output.push(key + ': ' + this[key]);
                }
                return output.join(', ');
            }
        };

        augment(Author, Mixin);

        var author = new Author('Xiaoxuan', ['JavaScript Design Patterns']);
        var serializedString = author.serialize();

        /* 神奇好用的工具函数 augment */

        function augment(receivingClass, givingClass) {
            for(methodName in givingClass.prototype) {
                if(!receivingClass.prototype[methodName]) {
                    receivinngClass.prototype[methodName] = givingClass.prototype[methodName];
                }
            }
        }          

        /* 神奇好用的工具函数 augment 改进版 可以Mixin特定方法，不一定全部 */

        function augment(receivingClass, givingClass) {
            if(arguments[2]) { //Only giving certain methods.

                for(var i = 2,len = arguments.length; i < len; i++) {
                    receivingClass.prototype[arguments[i]] = givingClass.prototype[arguments[i]];
                }

            } else { //giving all methods.

                for(methodName in givingClass.prototype) {
                    if(!receivingClass.prototype[methodName]) {
                        receivinngClass.prototype[methodName] = givingClass.prototype[methodName];
                    }
                }

            }
        }   

        /* Usage */
        augment(Author, Mixin, 'serialize');

    4.7*  就地编辑API设计(点击文字变为文本框，用户可就地编辑，分别使用三种继承方式) 非常好的一个例子
    
        (1)  类式继承
        /* EditInPlaceField class */

        见dp_demo4_1, dp_demo4_2   

        (2)  原型式继承解决方案

        见dp_demo4_3

        (3)  掺元类解决方案

        见dp_demo4_4

        见dp_demo4

    4.8  继承的使用场合

        继承会使代码更加复杂，更难被JavaScript新手理解，所以只应该用在它能带来好处胜过缺点的地方。它的好处
        表现在代码重用方面。通过建立类或对象之间的继承关系，有些方法我们只需要定义一次，同样，如果修改这些
        方法或排查其中错误，那么由于其定义在一个位置，所以方便很多。

        各种继承都有其优缺点，在内存效率上比较重要的场合原型式继承（及clone函数）是最佳选择，熟悉其他面向对象
        语言的程序员可以使用类式继承，并且在两者中搭配使用Mixin，事半功倍！

        比较简单的JavaScript程序很少需要用到这种程度的抽象，只有比较大型比且很多程序员参与的项目才需要这样。 

--- 2014 04 10 - 2014 04 12 ---
第五章 : 单体模式

    单体(singleton)模式是JavaScript中最基本但又是最有用的模式之一，它可以比其他任何模式都更常用。这种模式
    提供了一种将代码组织为一个逻辑单元的手段，这种逻辑单元中的代码可以通过单一的变量进行访问，通过确保单体
    对象只存在一份实例，你就可以确信自己的所有代码使用的都是同样的全局资源。

    单体类在JavaScript中有许多用途。他们可以用来划分命名空间，以减少网页中全局变量的数目。它们还可以在一种
    名为分支(branching)的技术中用来封装浏览器之间的差异(借助分支技术)，你可以把代码组织得更为一致，从而使其
    更容易阅读和维护。

    这种模式在JavaScript中非常重要，也许比在其他语言中更重要，在网页中使用全局变量有很大的风险，而用单体模式
    创建的命名空间则是清除这些全局变量的最佳手段之一。仅此一个原因就该掌握这种模式，更别说还有很多别的用途！

    5.1  单体的基本结构
        较高级的单体模式我们和还是放到后面讲，这里先讨论最基本的类型。最简单的单体实际上就是对象字面量，它有
        一批有一定关联的方法和属性组织在一起：

        /* Basic Singleton. */

        var Singleton = {
            attribute1 : true,
            attribute2 : 10,

            method1 : function() {
              //...
            },

            method2 : function() {
              //...
            }
        };
        //在这个实例中，所有成员变量和方法都可以通过Singleton来访问，可以使用圆点运算符:
        Singleton.attribute1 = false;
        var total = Singleton.attribute2 + 5;
        var result = Singleton.method1();

        /*
         * 单体创建后可以修改其属性和方法，这其实违背了面向对象的设计，JavaScript的对象都是易变的
         * 而且无法阻止(闭包除外)。
         * 并非每个对象字面量都是单体，如果只是模仿关联数组，那就不是。而如果是组织属性和方法，那就是。
        */

    5.2  划分命名空间
        单体由两部分组成，包含着属性和方法的对象本身以及用于访问它的变量(通常是全局的),以便在全局可以访问它
        这是单体模式的要点。只有这个全局变量可以访问单体内的属性和方法，可以这么说，这些属性和方法都被圈在
        这个命名空间里了。命名空间是JavaScript编程的一个重要工具，我们很容易一不留神就重写了一些重要方法，
        这造成的命名冲突恶果我们完全可以用命名空间来避免。甚至我们有时会面临别人的代码，插件、库等等，很容易
        就出现冲突造成困惑，所以有时我们可以给自己的所有代码用上全局封装，模块化。

    5.3  用作特定网页专用代码的包装器的单体
        
        /* Generic Page Object */

        Namespace.PageName = {

            //Page contants.
            CONSTANT_1 : true,
            CONSTANT_2 : 10,

            //Page methods.
            method1 : function() {
                //...
            },

            //Initialization method.
            init : function() {
                //...init here.
            }
        }

        //Invoke the initialization method after the page loads.
        addLoadEvent(Namespace.PageName.init);

        /*  
         *  我们用一个在web中很常用的用法，我们经常要用JavaScript为表单添加功能。出于平稳退化方面的考虑
         *  通常先创建一个不依赖JavaScript的、使用普通提交机制完成任务的纯HTML网页，然后用JavaScript控制
         *  表单的行为，提供一些额外的特性:  
        */

        见dp_demo5_1

    5.4  拥有私用成员的单体
    
        (1)  用下划线表示法

        (2)  使用闭包 (这种模式叫做单体模式，又叫做模块模式，指把相关属性方法组织为模块并划分命名空间)

        var Xx = window.Xx || {}; //定义字面量

        /*
         *  此方法和对象字面量扩充法不同在于可以用闭包实现真正的私用成员
         *  任何声明在这个匿名函数内(但不是在那个对象字面量中)的属性和方法都只能被同一个闭包中声明的其他
         *  函数访问。可以区分公用和私用成员
         *  这些闭包在匿名函数执行过后仍然存在，所以声明在其中的函数和方法总能从匿名函数所返回的对象内部访问
        */

        Xx.module1 = (function() { //立即执行函数在创建模块时很实用

            //private members.
            var privateAttribute1 = '';
            var privateAttribute2 = '';

            var privateMethod1 = function() {
                //...
            }
            var privateMethod2 = function() {
                //...
            }

            //public members.           
            return {
                
                publicAttribute1 : '',
                publicAttribute2 : '',

                publicMethod1 : function() {
                    //...
                },
                publicMethod2 : function() {
                    //...
                }

            };

        })(); //end of Xx.module1

    5.5  惰性实例化

            前面所讲的单体模式的各种实现方式有一个共同点，单体对象都是在脚本加载后被创建出来，对于资源密集型的
        或者配置开销甚大的单体，也许更合理的做法是将其实例化推迟到需要使用它的时候，这种技术被称为------------
        "惰性加载"(lazy loading),他最常用于那些必须加载大量数据的单体而那些被用作命名空间、特定网页专用代码包装
        器或组织相关实用方法的工具的单体最好还是立即实例化。

            这种惰性加载单体的特别之处在于，对他们的访问必须借助于一个静态方法。应该这样调用其方法：
        Singleton.getInstance().methodName(),而不是这样调用：Singleton.method()。getInstance方法会检查单体是否
        已经被实例化。如果还没有，那么它将创建并返回其实例。如果单体已经实例化，那么它将返回现有实例。下面我们
        从前面那个拥有真正的私用成员的单体的基本框架出发示范一下如何把普通单体转化为惰性加载单体：

        /* Singleton with Private Members */

        MyNamespace.Singleton = (function() {
            //private members.
            var privateAttribute1 = false;
            var privateAttribute2 = [1, 2, 3];

            function privateMethod1() {
                //...
            }
            function privateMethod2(args) {
                //...
            }

            //public members.
            return {
                
                publicAttribute1 : true,
                publicAttribute2 : 10,

                publicMethod1 : function() {
                    //...
                },
                publicMethod2 : fucntion() {
                    //...
                }

            };
        })();

        <------------------- 接下来进行神奇的转换 ------------------->

        /* General skeleton for a lazy loading singleton, step 1. */

        MyNamespace.Singleton = (function() {

            var uniqueInstance; //Private attribute that holds the single instance.

            function constructor() { //All of the normal singleton code goes here 
                var Attribute1 = false;
                var Attribute2 = [1, 2, 3];

                function Method1() {
                    //...
                }
                function Method2(args) {
                    //...
                }
            }

            return {
                getInstance : function() {
                    if(!uniqueInstance) { //Instantiate only if the instance doesn't exist
                        uniqueInstance = constructor();
                    }
                    return uniqueInstance;
                }
            };

        })();
        //调用方法也要跟着修改
        MyNamespace.Singleton.getInstance().Method();

    5.6  分支
            分支(branching)是一种用来把浏览器间的差异封装到在运行期间进行设置的动态方法中的技术。举个例子来说，
        假设我们需要创建一个返回XHR对象的方法，这种XHR对象在大多数浏览器中是XMLHttpRequest类的实例，在IE早期
        版本中则是某种ActiveX类的实例，这样一个方法通常会进行浏览器嗅探或者对象探测。如果不使用分支技术，那么
        每次调用这个方法时，所有那些浏览器嗅探代码都要再运行。要是这个方法的调用很频繁，那么这样会严重缺乏效率。
            更有效的做法就是只在脚本加载时一次性的确定针对特定浏览器的代码，这样一来，在初始化完成之后，每种浏
        览器都只会针对他的JavaScript实现而设计的代码，能够运行时动态确定函数代码的能力，正是JavaScript的高度灵
        活性和强大表现的一种体现，这种类型的优化很容易理解，它能提高调用这些函数的效率。
            例如分支技术实现XHR对象

        /* singleXhrFactory singleton  */

        var SingleXhrFactory = (function() {

            //three branches
            var standad = {
                createXhrObject : function() {
                  return new XMLHttpRequest();
            };
            var activeXNew = {
                createXhrObject : function() {
                  return new ActiveXObject('Msxml2.XMLHTTP');
            };
            var activeXOld = {
                createXhrObject = function() {
                  return new ActiveXObject('Microsoft.XMLHTTP');
            };

            //to assign the branch, try each method;return whatever dosen't fail.
            var testObject;
            try {

                testObject = standard.createXhrObject();
                return standard; //Return this if no error was thrown.

            } catch(e) {

                try {
                    testObject = activeXNew.createXhrObject();
                    return activeXNew; //Return this if no error was thrown.
                } catch(e) {

                    try {

                        testObject = activeXOld.createXhrObject();
                        return activeXOld;

                    } catch(e) {
                        throw new Error('No Xhr Object found in this environment.');
                    }

                }

            }

        })();   // 类似多态性， 运行时多态
        //用了分支技术后，所有这些特性嗅探都只会执行一次，而不是每生成一个对象就要执行一次，这是一种非常有效的
        //技术，它适用于任何只有在运行时才能确定具体实现的情况，接下来工厂模式还会再说这方面的话题。

    5.8  单体模式的适用场合

        从为代码提供命名空间到增强其模块性这个角度来说，应该尽量多使用单体模式，是JavaScript中最有效的模式之一
        几乎适用于所有大大小小的项目，
            在简单的快餐性项目中，我们可以创建命名空间，将代码组织在一个全局变量下。
            稍大些的项目，单体可以把相关代码组织起来，以便日后维护，或者把数据和代码安置在一个众所周知的单一位置
            大型项目中，可以起到优化作用，那些开销较大却又很少用的组件包装在惰性加载单体中，特定代码组织在分支中

        单体在JavaScript中尤为重要，远远超过它在其他语言中的重要性，因为JavaScript中的全局变量非常危险！！！
        
    5.9  单体模式之利

            单体模式只要好处就是对代码的组织，把相关属性和方法组织在一个不会被多次实例化的单体中，可以使代码的
        调试和维护变得轻松，描述性的命名空间还可以增强代码的自我说明性，有利于新手的阅读与理解。把方法包装在单体
        中，可以房子他们被其他程序员误改，还可以防止全局命名空间被一大推变量弄得一团糟，单体可以把你的代码与第三
        方代码很好的隔离开来，从而在整体上提高网页的稳定性。
            单体模式的一些高级变体可以在开发周期后期对脚本进行优化，提升其性能，使用惰性实例化技术，可以直接需要
        对象时再加载，减少不使用那个变量的用户的带宽和内存。通过运行时的条件确定赋给单体变量的对象字面量，你可以
        创建出为特定环境量身定制的方法，这种方法不会在每次调用时都再浪费时间去检查运行环境。

    5.10 单体模式之弊

            由于单体模式提供的是一种单点访问，所以它有可能导致模块间的强耦合，这是这种模式受到的主要批评，这个
        批评也很中肯，有时创建一个可实例化的类更为可取，哪怕它只会被实例化一次。单体模式的强耦合也不利于单元测试，
        单体最好还是留给定义命名空间和实现分支。当然以后的学习还会见识到更多好的模式，只有在恰当的时候用起来才是
        真重要的！！！

    5.11 小节

            创建可重用的模块化代码。寻求组织和说明代码的各种方法，创建可被大众使用的API才是最终目标。做一个值得
        信赖的高级JavaScript程序员！！！   

--- 2014 04 13 ---
第六章 : 方法的链式调用  流行的JS库大多采用

    6.0  前言   

        本章研究的是JavaScript对方法进行链式调用的能力。应用程序开发人员可以使用一些简单的技术来改进自己的代码
    编写工作。你可以写一些函数来处理各种常见的任务，以节省时间，也可以改进一下代码的实现方式，最后，你可以把链
    式调用用在自减所写的整个JavaScript库，把自己喜欢的方法连起来调用。

        例子:  
        //without chaining
        addEvent($('example'), 'click', function() {
            setStyle(this, 'color', 'green');
            show(this); 
        });

        //with chaining
        $('example').addEvent('click', function() {
            $(this).setStyle('color', 'green').show();
        });   

    6.1  调用链的结构

        (function() {
            //Use a private class.
            function _$(els) {
                this.elements = [];
                for(var i = 0, len = els.length; i < len; ++i) {
                    var element = els[i];
                    if(typeof element === 'string') {
                        element = document.getElementById(element);
                    }
                    this.elements.push(element);
                }
            }

            _$.prototype = {
                each : function(fn) {
                    for(var i = 0, len = this.elements.length; i < len; ++i) {
                        fn.call(this, this.elements[i]);
                    }
                    return this;
                },
                setStyle : function(prop, val) {
                    this.each(function(el) {
                        el.style[prop] = val;
                    });
                    return this;
                },
                show : function() {
                    var that = this;
                    this.each(function(el) {
                        that.setStyle('display', 'block');
                    });
                    return this;
                },
                addEvent : function(type, fn) {
                    var add = function(fn) {
                        if(window.addEventListener) {
                            el.addEventListener(type, fn, false);
                        } else if(window.attachEvent) {
                            el.attachEvent('on'+type, fn);
                        }
                    };
                    this.each(function(el) {
                        add(el);
                    });
                    return this;
                }
            };

            //The public interface remains the same.
            window.$ = function() {
                return new _$(arguments);
            };
        })();
    
        /* Usage */
        $(window).addEvent('load', function() {
            $('test-1').show().
                setStyle('color', 'green').
                addEvent('click', function(e) {
                    $(this).setStyle('color', 'red');
                });
        })

    6.2  设计一个支持方法链式调用的JavaScript库

            前面的$函数的改造只提供了对几种常见的使用函数进行链式调用的支持，但是你可以尽情对其扩充。设计一个
        JavaScript库需要深思熟虑，一个库不一定需要成百上千行代码，它的功能决定了它的大小，你可以借鉴一个各种
        JavaScript库中包含的最常用的特性，如图：

        特性    说明
        事件    添加和删除事件监听器，对事件对象进行规范化处理
        DOM     类名管理，样式管理
        Ajax    对XMLHttpRequest进行规范化处理

        Function.prototype.method = function(name, fn) {
            this.prototype[name] = fn;
            return this;
        };
        (function() {
            function _$(els) {
                //...
            }
            /*
                Events
                *  addEvent
                *  getEvent
            */
            _$.method('addEvent', function(type, fn) {
                //...
            }).method('getEvent', function(e) {
                //...
            }).
            /*
                DOM
                *  addClass
                *  removeClass
                *  replaceClass
                *  hasClass
                *  getStyle
                *  setStyle
            */
            method('addClass', function() {
                //...
            }).method('removeClass', function() {
                //...
            }).method('replaceClass', function() {
                //...
            }).method('hasClass', function() {
                //...
            }).method('getStyle', function() {
                //...
            }).method('setStyle', function() {
                //...
            }).
            /*
                Ajax
                *  load. Fetches an HTML fragment from a URL and inserts it into an element.
            */
            method('load', function(uri, method) {
                //...
            });
            window.$ = function() {
                return new _$(arguments);
            };
        })(); 

        //搭建好这个API的架子之后，现在该着重考虑的就是它的使用着可能是些什么人，有可能造成冲突，所以最好的
        //办法就是添加一个安装器(installer)

        Function.prototype.method = function(name, fn) {
            //...
        };
        (function() {
            function _$(els) {
                //...
            }
            _$.method('addEvent', function(type, fn) {
                //...
            });

            window.installHelper = function(scope, interface) {
                scope[interface] = function() {
                    return new _$(arguments);
                }
            };
        })();

        //用户可能会这样使用它：
        installHelper(window, '$');

        $('example').show();

        //下面是个更复杂的例子，它演示了如何把这种功能添加到一个事先定义好的命名空间对象中：

        //Define a namespace without overwriting it if it already exists.
        window.com = window || {};
        com.example = com.example || {};
        com.example.util = com.example.util || {};

        installHelper('com.example.util', 'get');

        (function() {
            var get = com.example.util.get;
            get('example').addEvent('click', function() {
                get(this).addClass('hello');
            });
        })();

    6.3  使用回调从支持链式调用的方法获取数据  

        //有时我们并不想每个函数都为了能链式返回this对象，比如取值器get函数，所以我们可以用回调技术返回
        //所要的数据，下面的例子用了普通方法和回调方法

        //Accessor without function callbacks: returning required data in accessors.
        window.API = window.API || function() {
            var name = 'hello world';
            //Privileged mutator method.
            this.setName = function(newName) {
                name = newName;
                return this;
            };
            //Privileged accessor method.
            this.getName = function() {
                return name;
            };  
        };

        //Implementation code.
        var o = new API();
        console.log(o.getName());
        console.log(o.setName('xiaoxuan').getName());

        //Accessor with function callbacks.
        window.API2 = window.API2 || function() {
            var name = 'Hello World';
            //Privileged mutator method.
            this.setName = function(newName) {
                name = newName;
                return this;
            };
            //Privileged accessor methods.
            this.getName = function() {
                callback.call(console, name);
                return this;
            };
        };

        //Implementation code.
        var o2 = new API2();
        o2.getName(console.log).setName('xiaoxuan').getName(console.log); //纯链式，究极写法，牛逼！！！  

--- 2014 04 14 - 2014 04 15, 2014 04 23 - 2014 04 24，2014 04 30  2014 0504 - 2014 0505 ---
第七章 : 工厂模式

    前言：
    一个类或者对象中往往包含别的对象。在创建这种成员对象时，你可能习惯于使用常规方法，即用new关键字和类构造函数
    问题在于这会导致相关的两个类之间产生依赖性，本章将讲述一个有助于消除这两个类之间依赖性的模式，它使用一个方法
    来决定究竟要实例化哪个具体的类，我们既要讨论简单的工厂模式，也要讨论更复杂的工厂模式，前者另外使用一个类，
    通常是单体来生成实例，而后者则使用子类来决定一个成员变量应该是哪个具体的类的实例。

    7.1  简单工厂

    /* BicycleShop class */

    var BicycleShop = function() {};
    BicycleShop.prototype = {
        sellBicycle : function(model) {
            var bicycle;

            switch(model) {
                case 'The Speedster':
                    bicycle = new Speedster();
                    break;
                case 'The Lowrider' :
                    bicycle = new Lowrider();
                    break;
                case 'The Comfort Cruiser' :
                default :
                    bicycle = new ComfortCruiser();    
            }
            Interface.ensureImplements(bicycle, Bicycle);
            bicycle.assembel();
            bicycle.wash();

            return bicycle;
        }
    };

    //见dp_demo7_1, dp_demo7_2

    7.2  工厂模式

    真正的工厂模式与简单工厂模式的区别在于，他不是使用另外一个类或对象来创建自行车（就像前面的例子所做的那样），
    而是使用一个子类。按照正式定义，工厂是一个将其成员对象的实例化推迟到子类中进行的类。我们还是以BicycleShop为
    例来说明简单工厂和工厂模式之间的差别。
        我们打算让各个自行车商店自行决定从哪个厂家进货，出于这个原因，单单一个BicycleFactory对象将无法提供需要的
    所有自行车实例。我们可以把BicycleShop设计为抽象类，让子类根据各自进货渠道实现其createBicycle方法：

    见dp_demo7_3

        因为两个生产厂家生产的自行车款式完全相同，所以顾客买车时可以不用关心车究竟是哪家生产的。要是他们只想要
    Acme生产的自行车，他们可以去Acme专卖店去买。
        增加对其他生产厂家的支持很简单，只要在创建一个BicycleShop的子类并进行重定义其createBicycle工厂方法即可
    我们可以对其各个子类进行修改，以支持相关厂家的其他型号的产品。这是工厂模式的最重要的特点，对Bicycle进行一般
    性操作的代码可以写在父类里，而具体的Bicycle对象进行实例化的工作则留到子类中，一般性的代码被集中在一个位置，
    而个体性的代码则被封装在子类中。

    7.3  工厂模式的适用场合
        创建新对象最简单的办法就是使用new关键字和具体类，只有在某些场合下，创建和维护对象工厂所带来的额外复杂性
    才是物有所值的，本节概括了这些场合。
    （1）
        动态实现 : 运行时多态
    （2）
        节省设置开销
        如果对象需要进行复杂并且彼此相关的设置，那么使用工厂模式可以减少每种对象所需要的代码量。如果这种设置只需
    要为特定的类型的所有实例执行一次即可，这种作用尤其突出。把这种设置代码放到类的构造器中并不是一种高效的做法，
    这是因为即使设置工作已经完成，但是每次实例化的时候这些代码还是会执行，而且这样做会把设置的代码分散到不同的类
    中。工厂方法非常适合于这种场合。他可以实例化所有需要的对象之前一次性的进行设置，无论有多少种类被实例化，这种
    办法都可以让设置代码集中在一个地方。设置代码都放在一个地方，以后的维护也十分方便。
    
    7.4  示例： XHR工厂
        用Ajax技术发起异步的请求是现在web开发中一个常见的任务，用于发起请求的对象是某种类的实例，具体是哪种类取
    决于用户的浏览器类型，如果代码中多次用到Ajax，那么明智的做法就是把创建这种对象的代码提取到一个类中，并创建
    一个包装器来包装实际发起请求时所要经历的一系列步骤，简单工厂非常适合这种场合，根据浏览器能力的不同生成一个
    XMLHttpRequest或ActiveObject实例:

    见dp_demo7_4, dp_demo7_4_1

    7.5  示例： RSS阅读器

    见dp_demo7_5  
        
    7.6  工厂模式之利
        工厂模式的主要好处在于消除对象间的耦合，通过使用工厂方法而不是new关键字及具体类，你可以把所有实例化代码
    集中在一个位置，这可以大大简化更换所有的类或运行期间动态选择所用的类工作。在派生子类时它也提供灵活性，使用工
    厂模式，你可以先创建一个抽象类的父类，然后在子类中创建工厂方法，从而把成员对象的实例化推迟到更专门的子类中进
    行。
        所有这些好处都与面向对象的两条原则有关：弱化对象见得耦合，防止代码的重复，在一个方法中进行类的实例化，可
    以消除重复性的代码，这是在用一个对接口的调用取代一个具体的实现，这些都有助于创建模块化的代码。

    7.7  工厂模式之弊
        可能有些人禁不住把工厂方当万金油，把普通的构造函数抛弃。new实例化可以让代码更清晰可读，要明确使用场合，
    切勿滥用。如果拿不定主意，可以不用，因为在重构代码时还有机会用。

--- 2014 0505 - 2014 0509 ---
第八章 : 桥接模式

    在实现API的时候，桥接模式非常有用，实际上，这也许是被用的最不够充分的模式之一。在所有模式中，这种模式最容易
    立即付诸实践。在设计一个Javascript API的时候，可以用这个模式来弱化它与使用它的类和对象之间的耦合。按GoF的定
    义，桥接模式的作用在于“将抽象与其实现隔离开来，以便二者独立变化”。这种模式对于JavaScript中常见的事件驱动的编
    程大有裨益。
    如果你刚进入JavaScript API开发的世界，那么很可能要创建许多获取(getter)、设置方法(setter)、请求方法(request)
    以及别的基于动作的方法。无论它们是用来创建Web服务API还是还是普通的取值器(accessor)方法和赋值器(mutator)方法
    在实现过程中桥接模式都有助于保持API代码的简介。

    8.1  示例 : 事件监听器
        桥接模式最常见的实际应用场合之一是事件监听器回调函数。假设有一个名叫getBeerById的API函数，它根据一个标示
    符返回有关某种啤酒的信息。那个被点击的元素很可能具有啤酒的标识符信息，它可能是作为元素自身的ID保存，也可能是
    作为别的自定义属性保存，下面是一种做法:

        addEvent(element, 'click', getBeerById);
        function getBeerById(e) {
            var id = this.id;
            asyncRequest('GET', 'beer.uri?id=' + id, function() {
                //callback response.
                console.log('Requested Beer : ' + resp.responseText);
            });
        }//局限性：只可以在浏览器模式使用，显然API不应局限如此

        function getBeerById(id, callback) {
            //Make request for beer by ID, then return the beer data
            asyncRequest('GET', 'beer.uri?id=' + id, function() {
                //callback response.
                callback(resp.responseText);
            });
        }

    8.2  桥接模式的其他例子  

        除了在事件回调函数与接口之间进行桥接外，桥接模式也可以用于连接公开的API代码和私用的实现代码。此外，它还
    可以把多个类联结在一起。从类的角度上看，这意味着把接口作为公开的代码编写，而把类的实现作为私用代码编写。
        如果公用的接口函数抽象了一些也许应该属于私用性的(尽管在此情况下，它不一定非得是私用的)较复杂的任务，那么
    可以使用桥接模式来收集某些私用性的信息。可以用一些具有特殊意义的方法作为桥梁以便访问私用变量空间，而不必冒险
    下到具体实现的浑水中。这一特例中德桥接函数又称为“特权函数”，第三章对此有详细说明。

        var Public = function() {
            var secret = 3;
            this.privilegedgedGetter = function() {
                return secret;
            };
        };
        var o = new Public();
        var data = o.privilegedGetter();

    8.3  用桥接模式联结多个类
        
        在现实生活中桥梁可以把多种事物联结起来，在JavaScript中也是如此：

        var Class1 = function(a, b, c) {
            this.a = a;
            this.b = b;
            this.c = c;
        };    
        var Class2 = function(d) {
            this.d = d;
        };
        var BridgeClass = function(a, b, c, d) {
            this.one = new Class1(a, b, c);
            this.two = new Class2(d);
        };
        //这看起来很像一个适配器

    8.4  示例 ： 构建XHR连接队列
        见dp_demo8_4

    8.5  桥接模式的适用场合
        很难想象，不使用桥接模式的事件驱动编程会是什么样子，但是JavaScript编程新手们常常沉迷于事件驱动开发的函
    数式风格，忘了编写接口---哪怕面对的是复杂的操作。判断什么地方应该使用桥接模式通常很简单。假设有如下代码：

        $('example').onclick = function() {
            new RichTextEditor();
        };
        从中你无法看出那个编辑器要显示在什么地方、他有哪些配置选项以及怎样修改它。这里的要诀就是让接口“可桥接”，
        实际上就是可配置。

    8.6  桥接模式之利
        掌握如何在软件开发中实现桥接模式，受益的不只是你，还有那些负责维护你的作品的人。把抽象与其实现隔离开，
    有助于独立地管理软件的各组成部分。Bug也因此更容易查找，而软件发生严重故障的可能性也减小了。说到底，桥接元素
    应该是粘合每一个抽象的粘合因子。

    8.7  桥接模式之弊
        在我们看来，这种模式并没有多少真正的缺点。前面讲述它的优点的时候已经提过了，它只会让API更加健壮、提高组
    件的模块化程度并促成更简洁的客户端系统实现。不过，这些益处是有代价的，比如造成性能和系统复杂性负面影响。

    8.8  小节
        用GoF的话来说，桥接模式“将抽象与实现隔离开来，以便二者独立变化”。它可以促进代码的模块化、促成更简洁的实现
    并提高抽象的灵活性。它可以用来把一组类和函数连续起来，而且提供了一种借助于特权函数访问私用数据的手段。    
             
--- 2014 0509 - 2014 0512 ---
第九章 : 组合模式

    （0）组合模式是一种专为创建web上的动态web上的动态用户界面而量身定制的模式。使用这种模式，可以用一条命令在多个
    对象上激发复杂的或递归的行为。这可以简化粘合性代码，使其更容易维护，而那些复杂行为则被委托给对象。
        组合模式为操劳过度的JavaScript程序员带来了两大好处。
    （1）你可以用同样的方法处理对象的集合与其中的特定子对象。组合对象(composite)与组成它的对象实现了同一批操
    作。对组合对象执行的这些操作将向下传递到所有的组成对象（constituent object），这样一来所有的组成对象都会执行同
    样的操作。在存在大批对象的情况下，这是一种非常有效的技术。藉此你可以不着痕迹地用一组对象替换一个对象，反之亦然
    。这有助于弱化各个对象之间的耦合。
    （2）它可以用来一批子对象组织成树形结构，并且使整棵树都可以被遍历。所有组织对象都实现了一个用来获取其子对
    象的方法。借助这个方法，你可以隐藏实现的细节并随心所欲地组织子对象。任何使用这个对象的代码都不会对其内部实现
    形成依赖。
        本章将示范在JavaScript中实现组合模式的方法，并讨论其适用场合。

    9.1  组合对象的结构

                        组合对象
                           |
        组合对象        组合对象      叶对象
           |               |
    叶对象       叶对象 叶对象       叶对象

    9.2  使用组合模式
        只有同时具备如下两个条件时才适合使用组合模式：
        （1）存在一批组织成某种层次体系的对象（具体的结构在开发期间可能无法得知）。
        （2）希望对这批对象或其中的一部分对象实施一个操作。

    组合模式擅长对大规模的对象进行操作，他专为组织这些对象并把操作从一个层次向下一个层次传递而设计。藉此你可以弱化
    对象间的耦合并可互换地使用一些类或实例。按这种模式编写的代码模块化程度更高，也更容易维护。

    9.3  示例：表单验证

    9.4  示例： 图片库

    9.5  组合模式之利
        使用组合模式，简单的操作也能产生复杂的结果。你不必编写大量手工遍历数组或其他数据结构的粘合代码，只需对最顶
    层的对象执行操作，让每一个子对象自己传递这个操作即可

--- 2014 0512 - 2014 0512，2014 0524 - 2014 0525 --
第十章 : 门面模式

    门面模式有两个作用：一是简化类的接口；二是消除类与使用它的客户代码之间的耦合。在JavaScript中，门面模式常常是开
    发者最亲密的朋友。它是几乎所有JavaScript库的核心原则。通过创建一些便利的方法让复杂系统变得简单易用，门面模式可
    以使库提供的工具更容易理解，使用这个模式，程序员可以间接地与一个子系统打交道，与直接访问子系统相比，这样做更不
    容易出错。

    门面模式简化了诸多错误记录或跟踪页面试图统计数据这类常用的或重复性的任务。通过添加一些便利方法（这种方法是对原
    有的一些方法的组合利用），它还可以让对象的功能显得更加完善。

    简化复杂接口，可以在幕后为你进行错误检查、清除不再需要的大对象，以及用一种更加容易的方式展示对象的功能。

    门面模式并非必不可少。同样的任务不用它也能完成。这是一种组织模式。他可以用来修改类和对象的接口，使其更便于使
    用。它可以让程序员过得更轻松，使他们的代码变得更容易管理。

    10.1

    例子：
    function addEvent(el, type, fn) {
        if(window.addEventListener) {
            el.addEventListener(type, fn, false);
        } else if(window.attachEvent) {
            el.attachEvent('on' + type, fn);
        } else {
            el['on' + type] = fn;
        }
    } //精心设计的API来包装不同意或不友好的API

    10.2  JavaScript库的门面性质

    创建自己的工具函数

    10.3  用作便利方法的门面元素
    
    //例子
    function a(x) {
        //do some stuff here...
    }  

    function b(y) {
        //do some stuff here...
    }

    function ab(x, y) {
        a(x);
        b(y);
    }

    var DED = window.DED || {};
    DED.util = {
        stopPropagation : function(e){
            if(e.stopPropagation()) {
                //W3C interface.
                e.stopPropagation();
            } else {
                //IE interface.
                e.cancelBubble();
            }
        },
        preventDefault : function(e) {
            if(e.perventDefault()) {
                //W3C interface.
                e.preventDefault();
            } else {
                //IE interface.
                e.returnValue = false;
            }
        },
        /* our convenience method */
        stopEvent : function(e) {
            DED.util.stopPropagation(e);
            DED.util.prevenetDefault(e);
        }
    };
    /* 
      尽管看起来很像，但门面模式并不是适配器模式。适配器（第11章将会详解）是一种包装器，用来对接口包装以便在不兼
      容的系统中使用它，而创建门面元素则图个方便。它并不用于达到与需要的特定接口的客户系统打交道这个目的，而是用
      于提供一个简化的接口。
    */

    10.4  示例：设置HTML元素的样式

    //设计一个简便函数
    setStyle(['foo', 'bar', 'baz'], 'color', 'red');

    function setStyle(elements, prop, val) {
        for(var i = 0, len = elements.length; i++) {
            document.getElementById(elements[i].style[prop] = val);
        }
    }
    
    //设想的形式
    setCSS(['foo'], {
        position : 'absolute',
        background : 'red',
        top : '50px',
        left : '300px' 
    });

    function setCSS(el, styles) {
        for( var prop in styles ) {
            if(!styles.hasOwnProperity(prop)) continue;
            setStyle(el, prop, styles[prop]);
        }
    } //达到效果，且这样写更像原生CSS设置

    10.5  示例 ：设计一个事件工具

    前面曾经说过，在处理跨浏览器问题时，最好创建一些门面函数。如果要设计一个大型库，那么最好把其中的所有的工具函数
    聚拢在一起，这样工具更好用，访问起来也更简单。鉴于各种浏览器在事件处理方面表现出的大量差异，我们开发一个事件工
    具很有必要：
        我们先从一个基本的框架开始，这里要用到单体模式。它位于DED.util命名空间中包含着我们要设计的各个静态方法：
        DED.util.Event = { //大概
            //bulk goes here...
        };

        DED.util.Event = { //粗略框架
            getEvent : function(e) {},
            getTarget : function(e) {},
            stopPropagation : function(e) {},
            preventDefault : function(e) {},
            stopEvent : function(e) {}
        };

        DED.util.Event = {
            getEvent : function(e) {
                 return e || window.event;
            },
            getTarget : function(e) {
                return e.target || e.srcElement;
            },
            stopPropagation : function(e) {
                if(e.stopPropagation()) {
                    e.stopPropagation();
                } else {
                    e.cancelBubble = true;
                }
            },
            preventDefault : function(e) {
                if(e.preventDefault()) {
                    e.preventDefault();
                } else {
                    e.returnValue = false;
                }
            },
            stopEvent : function(e) {
                this.stopPropagation();
                this.preventDefault();
            }
        };

        addEvent($('example'), 'click', function() {
            //who clicked me.
            console.log(DED.util.Event.getTarget(e));
            //stop propagating and prevent the default action.
            DED.util.Event.stopEvent(e);
        });

    10.6  实现门面模式的一般步骤

        找准自己的应用程序中感觉适合使用门面方法的地方后，就可以着手加入便利方法了，这些函数的名字应该仔细考虑，
        与它们的用途要相称，对于那种由几个函数组合而成的函数，一个简单的方法就是把相关函数的名称穿成一个函数名，
        并采用camel大写规范，或者也可以使用thisFunctionAndThatFunction这种形式。
        处理浏览器API的不一致属于另一种情况，此时要做的就是把分支语句代码放在新创建的门面函数中，辅以对象检查或
        浏览器嗅探等技术。为这种函数取名有点令人头痛，因为你面临的是实现类似功能的函数在不同浏览器中碰巧有着不同
        的名字，pageX和clientX，这里建议取一个好认的名字，并在代码文档中说明该门面函数的用途。

    10.7  门面模式的适用场合

        判断是否应该使用门面模式的关键在于辨认那些反复成组出线的代码。如果函数b出现在函数a之后这种情况经常出现，
        那么也许你应该考虑添加一个把这两个函数组合起来的门面函数。
        在自己的核心工具代码中加入门面函数的另一个可能目的是应对JavaScript内置函数在不同浏览器中的不同表现，这样
        做并不是因为不能直接使用这些API，而是因为在处理跨浏览器的差异问题时最好的办法就是把这些差异抽取到门面方法
        中。它们可以提供一个更一致的接口。addEvent函数就是一个例子。

    10.8  门面模式之利

        使用门面模式的目的就是让程序员过得更轻松一些，编写一次组合代码，然后就可以反复使用它，这有助于节省时间和精
        力。他们可以替你把硬骨头啃掉，而且提供了一个处理常见问题和任何的简化接口。
        门面方法方面了开发人员，并且提供了较高层的功能，如果不用门面模式的话这些功能实现起来可能会乏味而又费力，他
        们还能降低对外部代码的依赖程度，这位应用系统的开发增加了一些额外的灵活性。通过使用门面模式，可以避免与下层
        子系统的紧密耦合，这样就可以对这个系统进行修改而不会影响到客户端代码。

    10.9  门面模式之弊

        滥用，小题大做。引入库去解决小问题。

--- 2014 0525 - 2014 0527 ---
第十一章 : 适配器模式

    适配器模式可用来在现有接口和不兼容的类之间进行适配。使用这些模式的对象又叫做包装器（wrapper），因为它们是在用
    一个新的接口包装另一个对象。许多时候创建适配器同使用的情况。借助于适配器，你不用直接修改这些类也能使用他们。本
    章将考察一些这类场合，并探讨用这适配器模式链接对象的各种方式。

    11.1  适配器的特点

    作为一个实现不兼容系统之间的代码薄层。如果你有一个具有三个字符串参数的函数，但客户系统拥有的却是三个字符串的数
    组，此时就可以用一个适配器来衔接二者。
        架设你有一个对象，还有一个以三个字符串为参数的函数：
        var clientObject = {
            string1 : 'foo',
            string2 : 'bar',
            string3 : 'baz'
        };
        function interfaceMethod(str1, str2, str3) {
            //...
        }
        function clientToInterfaceAdapter(o) {
            interfaceMethod(o.string1, o.string2, o.string3);
        }
        clientToInterfaceAdapter(clientObject);

    11.2  适配原有实现
    
        比如生活中的电源适配器

    11.3  示例：适配两个库
    
        现在来个示例：讲述从
            Prototype : $
            YUI       : get

        //prototype $ function.
        function $() {
            var elements = new Array();
            for( var i = 0; i < arguments.length; i++ ) {
                var element = arguments[i];
                if( typeof elements == 'string' ) {
                    element = document.getElementById(element);
                }
                if( arguments.length == 1 ) return element;
                elements.push(element);
            }
            return elements;
        }            

        /* YUI get method. */
        YAHOO.util.DOM.get = function(el) {
            if( YAHOO.lang.isString(el) ) {
                return document.getElementById(el);
            }
            if( YAHOO.lang.isArray(el) ) {
                var c= [];
                for(var i = 0, len = el.length; i < len; i++) {
                    c[c.length] = YAHOO.util.DOM.get(el[i]);
                }
                return c;
            }
            if( el ) {
                return el;
            } 
            return null;
        }

        //适配器需要把这两个参数不同的方法适配起来，却很简单
        function PrototypeToYUIAdapter() {
            return YAHOO.util.DOM.get(arguments);
        } 

        function YUIToPrototypeAdapter(el) {
            return $.apply( window, el instanceof Array ? el : [el] );
        } 

        //然后,ok了
        $ = PrototypeToYUIAdapter; 
        //or
        YAHOO.util.DOM.get = YUIToPrototypeAdapter;

        11.4  示例： 适配电子邮件的API
        本例研究的是一个Web邮件API，它可以用来接收、发送邮件并执行一些特别的任务。我们将采用类Ajax技术从服务器获取
        消息，然后将消息载入DOM。在完成这个应用接口后，我们将讨论如何为其编写包装函数，以便那些期待一个不同接口的
        客户也能使用这个API
        要事先办，先看一下整个应用系统：略...

        11.5  适配器模式的适用场合
        适配器作为中间代码层，适用于新环境，新系统却和原系统API功能与设计基本一致，但接口形式稍有不同。

        11.6  适配器模式之利
        并非为自己量身打造的接口也无需为此大动手术

        11.7  适配器模式之弊
        稳定了的接口在为其做适配器，否则一变就又无法适配了。。。

--- 2014 0527 - 2014 05 28, 2014 06 17 ---
第十二章 : 装饰者模式
    
    本章讨论的是一种为对象添加特性的技术，它并不使用创建新子类这种手段，装饰者模式(decoration patten)可用来透明的
    把对象包装在具有同样接口的另一个对象之中。这样一来，你就可以给一个方法添加一些行为，然后将方法调用传递给原始对
    象。相对于创建子类来说，使用装饰者对象是一种更灵活的选择。这种模式特别适合Javascript(在本章后面讲到的动态接口
    时会体会这点)，因为js代码不怎么依赖对象的类型。

    12.1  装饰者的结构

    装饰着模式可以为对象增加功能，它可以用来替代大量子类，为了准确的说明这个概念，我们将进一步分析第7章所讲的那个
    自行车商店的例子。你上次见到的AcmeBicycleShop类的时候，顾客可以购买的自行车有4种型号。后来这家商店开始为每一种
    自行车提供额外的特色配件。现在顾客再加点钱就可以买到带前灯、尾灯等部件的车子。每一种可选配件都会影响到售价和车
    的组装方法。这个问题最基本的就是为选件的每一种组合创建一个子类。

        var AcmeComfortCruiser = function() { //... }; //The superclass for all of the other comfort cruisers

        var AcmeComfortCruiserWithHeadlight = function() { //... };
        var AcmeComfortCruiserWithTaillight = function() { //... };
        var AcmeComfortCruiserWithHeadlightAndTaillight = function() { //... };
        var AcmeComfortCruiserWithBasket = function() { //... };
        var AcmeComfortCruiserWithHeadlightAndBasket = function() { //... };
        var AcmeComfortCruiserWithTaillightAndBasket = function() { //... };
        var AcmeComfortCruiserWithHeadlightTaillightAndBasket = function() { //... };
        var AcmeComfortCruiserWithBell = function() { //... };
        //...子子孙孙无穷尽，装饰着模式是这个问题的最佳解决办法

        在这个例子中，选件类就是装饰者，而自行车类是他它们的组件(component)。装饰者对其进行了透明的包装，二者可以
        互换使用，这是因为它们实现了同样的接口。下面我们就来看看应该怎么样实现自行车装饰者类，首先要修改一下接口，
        加入一个getPrice()方法：

        /* The Bicycle interface */

        var Bicycle = new Interface('Bicycle', ['assemble', 'wash', 'ride', 'repair', 'getPrice']);

        var AcmeComfortCruiser = function() { 
            //...implements Bicycle.
        };
        AcmeComfortCruiser.prototype = {
            assemble : function() {
                //...
            },
            wash : function() {
                //...
            },
            ride : function() {
                //...
            },
            repair : function() {
                //...
            },
            getPrice : function() {
                //...
            }
        };

        /* The BicycleDecorator abstract decorator class. */

        var BicycleDecorator = function(bicycle) { //Implements Bicycle.
            Interface.ensureImplements(bicycle, Bicycle);
            this.bicycle = bicycle;
        };
        BicycleDecorator.prototype = {
            assemble : function() {
                return this.bicycle.assemble();
            },
            wash : function() {
                return this.bicycle.wash();
            },
            ride : function() {
                return this,bicycle.ride();
            },
            repair : fucntion() {
                return this.bicycle.repair();
            },
            getPrice : function() {
                return this.bicycle.getPrice();
            }
        };

        /* HeadlightDecorator class. */

        var HeadlightDecorator = function(bicycle) {
            //Call the superclass's constructor.
            HeadlightDecorator.superclass.constructor.call(this, bicycle);
        }
        extend(HeadlightDecorator, BicycleDecorator); //Excend the superclass.
        HeadlightDecorator.prototype.assemble = function() {
            return this.bicycle.assemble() + 'Attach headlight to handlebars.';
        };
        HeadlightDecorator.prototype.getPrice = function() {
            return this.bicycle.getPrice() + 15.00;
        };

        //使用：
        var MyBicycle = new AcmeComfortCruisers(); //Instantiate the bicycle.
        alert(myBicycle.getPrice()); //Returns 399.00
        myBicycle = new HeadlightDecorator(myBicycle); //Decorator the bicycle object.
        alert(myBicycle.getPrice()); //Now returns 414.00

    12.1.1  接口在装饰者模式中的角色

        它说明了装饰者模式必须实现那些方法，这有助于防止开发过程中的错误，通过创建一个具有一批固定方法的接口，
        你所面对的就不再是一个游移不定的目标。此外，它还可以在新版的工厂方法(参见12.3节)中用来确保所创建的对象
        都实现了必须的方法。
            如果装饰者对象与其组件不能互换使用，它就会丧失其功能，这是装饰者模式的关键特性，要注意防止装饰者和
        组件出现的接口方面的差异。这种模式的好处之一就是可以通过透明的使用对象装饰现有的系统的对象，而这并不会
        改变代码中德其他东西，只有装饰者和组件实现了同样的接口才能做到这一点。

    12.2  装饰者模式修改其组建的方式
        装饰者模式的作用就在于以某种方式对组件对象的行为进行修改。本节将介绍一些这方面的做法。

        （1）在方法之后添加行为
        在方法之后添加行为是最常见的修改方法的具体做法。具体而言就是先调用组件的方法，并在其返回后实施一些附加
        的行为。HeadlightDecarator的getPrice方法就是一个简单的例子：
        HeadlightDEcarator.prototype.getPrice = function(bicycle) {
            return this.bicycle.getPrice() + 15.00;
        };        

        var myBicycle = new AcmeComfortCruisers();
        alert(myBicycle.getPrice()); //Return 399.00

        myBicycle = new HeadlightDecarator(myBicycle);
        myBicycle = new HeadlightDecarator(myBicycle);
        myBicycle = new TaillightDecarator(myBicycle);

        alert(myBicycle.getPrice()); //Now returns 438.00
        //调用栈大体是这样的：TaillightDecorator对象上调用getPrice(),继而调用较外层的HeadlightDecarator的getPrice

        //实现一个提供车架颜色选择的装饰者

        /* FrameColorDecarator class. */

        var FrameColorDecarator = function(bicycle, frameColor) {
            //Call the superclass's constructor.
            FrameColor.superclass.constructor.call(this, bicycle);
            this.frameColor = frameColor;
        };
        extend(FrameColorDecarator, BicycleDecorator); //Extend the superclass.
        FrameColor.prototype.assemble = function() {
            return 'Paint the frame ' + this.frameColor + ' and allow it to dry. ' + this.bicycle.assemble();
        };
        FrameColor.prototype.getPrice = function() {
            return this.bicycle.getPrice() + 30.00;
        };

    12.2.3  替换方法

        /* 有时为了实现新行为必须对原有的方法进行整体替换，在此情况下，组件方法不会被调用（或虽然被调用但是其
        返回值会被抛弃）。作为这种用法的一个例子，我们创建一个实现自行车终身保修的装饰者： */
    
        /* LifetimeWarrantyDecorator class. */

        var LifetimeWarrantyDecorator = function() {
          //Call the superclass's constructor.
          LifetimeWarrantyDecarator.superclass.constructor.call(this, bicycle);
        };
        extend(LifetimeWarrantyDecorator, BicycleDecorator);
        LifetimeWarrantyDecorator.prototype.repair = function() {
          return 'This bicycle is coverd by a lifetime warranty. Please take it to an Acme bicycle shop. ';
        };
        LifetimeWarrantyDecarator.prototype.getPrice = function() {
          return this.bicycle.getPrice() + 199.00;
        };

        //这个装饰者把组件的repair方法替换为一个新方法，而组件的方法则不再会被调用。装饰者模式也可以根据某种条件
        //决定是否替换组件的方法，在条件满足时替换方法，否则就使用组件的方法。

        /* TimedWarrantyDecarator class. */

        var TimedWarrantyDecarator = function(bicycle, coverageLengthInYears) {
          //Implements Bicycle
          //Call the superclass's constructor.
          TimedWarrantyDecorator.superclass.constructor.call(this, bicycle);
          this.coverageLength = coverageLengthInYears;
          this.expDate = new Date();
          var coverageLengthInMs = this.coverageLength * 365 * 24 * 60 * 60 *1000;
          this.expDate.setTime(this,expDate.getTime() + coverageLengthInMs);
        }
        extend(TimedWarrantyDecorator, BicycleDecorator);
        TimedWarrantyDecorator.prototype.repair = function() {
          var repairInstructions;
          var currentDate = new Date();
          if( currentDate < this.expDate ) {
            repairInstructions = 'This bicycle is currently coverd by a warranty. ' +
            'Please take it to a Acme Bicycle shop';
          } else {
            repairInstructions = this.bicycle.repair();
          }

          return repairInstructions;
        };
        TimedWarrantyDecorator.prototype.getPrice = function() {
          return this.bicycle.getPrice() + (40.00 * this.coverageLength);
        };

    12.2.4  添加新方法

        前面例子所讲的修改都是发生在接口所定义的方法中（组件也具有这些方法），但这并不是一种必然的要求。装饰者也
        可以定义新方法，外围代码首先必须知道有这样的方法，由于这些新方法并不是在接口中定义的，而且它们是动态添加
        的，因此有必要进行类型检查，以验明用于包装组件的对象的最外层装饰者。

        /* BellDecorator class. */

        var BellDecorator = function(bicycle) { //implements bicycle
          BellDecorator.superclass.call(this, bicycle); //call the superclass's constructor
        };    
        extend(BellDecorator, BicycleDecorator); //Extend the superclass.
        BellDecorator.prototype.assemble = function() {
          return this.bicycle.assemble() + 'attach bell to handlebars.';
        };
        BellDecorator.prototype.getPrice = function() {
          return this.bicycle.getPrice() + 6.00;
        };
        BellDecorator.prototype.ringBell = function() {
          return 'Bell rung.';
        };

        /* The BicycleDecorator abstract decorator class, improved. */

        var BicycleDecorator = function(bicycle) { //implements Bicycle
          this.bicycle = bicycle;
          this.interface = Bicycle;

          //Loop through all of the attributes of this.bicycle and create pass-through
          //methods for any methods that aren't currently implemented.
          outerloop: for( var key in this.bicycle ) {
            //Ensure that the property is a function.
            if ( typeof this.bicycle[key] !== 'function' ) {
              continue outerloop;
            }
            //Ensure that the method isn't in the interface.
            for( var i = 0, len = this.interface.methods.length; i < len; i++ ) {
              if( key === this.interface.methods[i] ) {
                continue outerloop;
              }
            }

            //Add the new method.
            var that = this;
            !!!(function() {
              that[methodName] = function() {
                return that.bicycle[methodName]();
              };
            })(key);
          }
        }
        BicycleDecorator.prototype = {
          assemble: function() {
            return this.bicycle.assemble();
          },
          wash: function() {
            return this.bicycle.wash();
          },
          ride: function() {
            return this.bicycle.ride();
          },
          repair: function() {
            return this.bicycle.repair();
          },
          getPrice: function() {
            return this.bicycle.getPrice();
          }
        };

    12.3  工厂的角色
    
        前几节中已经提到，装饰者的应用顺序有时很重要。在理想情况下，装饰者应该能够以一种完全与顺序无关的方式创建，
        然而这并不总是能够办到，如果必须确保某种特定的顺序，那么可以为此使用工厂对象，实际上，不管顺序如何，工
        厂都是很适于创建装饰对象。本节将重写第7章中创建的AcmeBicycleShop类的createBicycle方法，以便用户可以指定自
        行车要配的选件，这些选件将被转换为装饰者，并在方法返回之前被应用到新创建的自行车对象上。

        /* AcmeBicycle factory class, with decorators. */

        var AcmeBicycleShop = function() {};
        extend(AcmeBicycleShop, BicycleShop);
        AcmeBicycleShop.prototype.createBicycle = function(model, options) {
          //Instantiate the bicycle object.
          var bicycle = new AcmeBicycleShop.models[model]();

          //Iterate through the options and instantiate decrators.
          for ( var i = 0, len = options.length; i < len; i++ ) {
            var decorator = AcmeBicycleShop.options[options[i].name];
            if ( typeof decorator !== 'function' ) {
              throw new Error('Decorator' + options[i].name + 'not found.');
            }
            var argument = option[i].arg;
            bicycle = new decorator(bicycle. argument);
          }

          //check the interface and return the finished object.
          Interface.ensureImplements(bicycle, Bicycle);
          return bicycle;
        };

        //Model name to class name mapping.
        AcmeBicycleShop.models = {
          'The Speedster'      : AcmeSpeedster,
          'The Lowrider'       : AcmeLowrider,
          'The Flatlander'     : AcmeFlatlander,
          'The Comfort Cruiser': AcmeComfortCruiser
        };

        //Option name to decorator class name mapping.
        AcmeBicycleShop.options = {
          'headlight'        : HeadlightDecorator,
          'taillight'        : TaillightDecorator,
          'bell'             : BellDecorator,
          'basket'           : BasketDecorator,
          'color'            : FrameColorDecorator,
          'lifetime warranty': LifetimeWarrantyDecorator,
          'timed warranty'   : TimedWarrantyDecorator  
        };

        如果顺序很重要，那么可以添加一些代码，在使用选件数组实例化装饰者之前对其进行排序。用工厂实例化自行车对象有
        许多好处。首先，不必了解自行车和装饰者的各种类名，所有这些信息都封装在AcmeBicycleShop类中。因此添加自行车型
        号和选件非常容易，只要把它们添加到AcmeBicycleShop.models或AcmeBicycleShop.options数组即可。作为一个示范，我
        们来比较一下创建带装饰的自行车对象的两种不同做法，第一种做法不使用工厂：

        var myBicycle = new AcmeSpeedster();
        myBicycle = new FrameColorDecorator(myBicycle, 'blue');
        myBicycle = new HeadlightDecorator(myBicycle);
        myBicycle = new TaillightDecorator(myBicycle);
        myBicycle = new TimedWarrantyDecorator(myBicycle, 2);

        //采用这种直接实例化对象的做法，与客户代码紧密耦合在一起的类不下5个。与此相比，下面所示的第二种做法使用了工
        厂，与客户代码耦合在一起的只有一个类，即那个工厂本身：

        var alecsCruisers = new AcmeBicycleShop();
        var myBicycle = alecsCruiser.createBicycle('The Speedster', [
          { name: 'color', arg: 'blue' },
          { name: 'headlight' },
          { name: 'taillight' },
          { name: 'timed warranty', arg: 2 }
        ]);

        该工厂会对经历了最后一道装饰的对象进行接口检查，以确保它实现了正确的接口，这意味着你可以相信它创造出来的对
        象能做你希望它做得任何事，这也意味着任何使用createBicycle方法的代码只管使用它创建出来的对象就行，不必关心它
        是一个自行车对象还是装饰者对象，这是由于它们实现了同样的接口，因此对于客户代码来说它们没有本质上的区别。
            最后要说的就是，如果有必要的话，工厂可以选择对选件进行排序，某些装饰者修改组件方法的方式决定了它们需要
        最先或者最后被应用，再在此情况下工厂的这种作用就尤其有用，那种会替换组件方法而不是对其扩充的装饰者需要放在
        最后创建，以确保其成为最外层的装饰者。

        12.4  函数装饰者

            装饰者并不局限于类。你也可以创建用来包装独立的函数和方法的装饰者。在某些语言中这是一种常见的技术，这种
        技术在Python中应用很广，以至于函数装饰者已经成为其语言核心中的内置成分。
            下面是一个简单的函数装饰者的例子，这个装饰者包装了另一个函数，其作用在于将被包装着的返回结果改为大写形
        式：
        function upperCaseDecorator(func) {
          return function() {
            return func.apply(this, arguments).toUpperCase();
          }
        }

        这个装饰者可以用来创建新函数，后者执行起来与普通函数没什么不同，下面的例子先定义了一个普通函数，然后将其装
        饰为一个新函数：
        function getDate() {
          return ( new Date ).toString();
        }
        getDateCaps = upperCaseDecorator(getDate);
        console.log( getDate() );
        console.log( getDateCaps() );

        BellDecorator.prototype.ringBellLoudly = upperCaseDecorator(BellDecorator.prototype.ringBell);
        var myBicycle = new AcmeComfortCruiser();
        myBicycle = new BellDecorator(myBicycle);

        alert(myBicycle.ringBell()); //return 'Bell rung'
        alert(myBicycle.ringBellLoudly()); //return 'BELL RUNG'

        函数装饰者在对另一个函数的输出应用某种格式或执行某种转换这方面很有用处。例如，你可以创建一个用来包装自行车
        类的assemble方法的函数装饰者，让它用别的语言返回组装指示（不过这会是一个非常庞大的装饰者）。你也可以创建一
        个函数装饰者用它来包装那种返回数值的函数，并将该数值转换为别的数制形式。函数装饰者给程序员带来了极大的灵活
        性，而实现它所需要的代码比大而全的类装饰者少得多。

        12.5  装饰者模式的适用场合

        如果需要为类增加特性或职责，从而该类派生子类的解决办法不实际的话，就应该使用装饰者模式。
        如果需要为对象添加特性而又不想使用该对象的代码的话，也可以采用装饰者模式动态透明的修改对象，所以它们很适合
        修改现有系统这一任务。相比卷入创建和维护子类的麻烦，创建和应用一些装饰者往往要省事得多。

        12.6  示例：方法性能分析器

        装饰者模式擅长为各种对象添加新特性，本例要创建的装饰者可以用来包装任何对象，以便为其提供方法的性你分析
        ---method profiling 功能，我们打算在每个方法调用的前后添加一些代码，分别用于启动计时器和停止计时器并报告结
        束。这个装饰者必须完全透明，这样才能应用与任何接口，我们先创建一个实现了计时功能的速成版装饰者，然后再改造
        其为通用型装饰者。

        我们需要一个用来测试的样例类。下面的ListBuilder类就是用于这个目的的，其唯一的功能就是在网页上创建一个有序列
        表：
        /* ListBuilder class. */

        var ListBuilder = function(parent, listLength) {
          this.parent = $(parent);
          this.listLength = listLength;
        };
        ListBuilder.prototype = {
          buildList: function() {
            var list = document.createElement('ol');
            this.parent.appendChild(list);

            for ( var i = 0; i < this.listLength; i++ ) {
              var item = document.createElement('li');
              list.appendChild(item);
            }
          }
        };
        我们首先要创建一个专用于这个ListBuilder类的装饰者，它将记录执行buildList方法所耗用的时间。我们用console.log
        输出这些结果，运行这段代码时，要知道并非所有浏览器都实现了console对象：
        /* SimpleProfiler class. */

        var SimpleProfiler = function(component) {
          this.component = component;
        };
        SimpleProfiler.prototype = {
          buildList: function() {
            var startTime = new Date();
            this.component.buildList();
            var elapsedTime = ( new Date() ).getTime() - startTime.getTime();
            window.console && console.log('biildList: ' + elapsedTime + 'ms');
          }
        };

        var list = ListBuilder('list-container', 5000); //Instantiate the object.
        list = new SimpleProfiler(list); //Wrap the object in decorator.
        list.buildList(); //Creates the list and displays the op time.

        /* MethodProfiler class. */

        var MethodProfiler = function(component) {
          this.component = component;
          this.timers = {};

          for ( var key in this.component ) {
            //Ensure that the property is a function.
            if ( typeof this.component[key] !== 'function' ) {
              continue;
            }

            //Add the method.
            var that = this;
            (function() {
              that[methodName] = function() {
                that.startTimer(methodName);
                var returnValue = that.component[methodName].apply(that.component, arguments);
                that.displayTime( methodName, that.getElapsedTime(methodName) );
                return returnValue;
              };
            })(key);
          } //end of for loop...
        };

        MethodProfiler.prototype = {
          startTimer: function(methodName) {
            this.timers[methodName] = ( new Date() ).getTime();
          },
          getElapsedTime: function(methodName) {
            return ( new Date() ).getTime() - this.timers[methodName];
          },
          displayTime: function(methodName, time) {
            window.console && console.log(methodName + ' : ' + 'ms');
          }
        };

        12.7  装饰者模式之利
        一切动态添加实现，不用事先知道组件对象的接口，在现有对象添砖加瓦这方面，装饰者模式为程序员带来了极大的灵活
        性。

        12.8  装饰者模式之弊

        1.依赖于严格的类型检查的代码可能会出问题，尽管在大多数时候JavaScript不进行类型检查，不过如果代码中包含它，
        就会无法匹配所需要的类型，通常装饰者模式对客户代码是完全透明的，不过，在这种情况下，客户代码就能感知装饰者
        与其他组件的不同。
        2.使用装饰者模式往往会增加构架的复杂程度，且一些语法细节让人生畏，特别是不熟悉这种模式的客户，所以，一定要
        多花些心思，确保自己的代码有良好的文档说明，并且容易理解。

        12.9  小结

        略...

--- 2014 06 17 - 2014 06 19 ---
第十三章 : 享元模式

    本章主要讨论的是另一种优化模式---享元(flyweight)模式，它最适合于解决因创建大量类似对象而累积的性能问题，这种模
    式在JavaScript中尤其有用，因为复杂的JavaScript代码很快会用光浏览器的可用内存。通过把大量独立的对象转化为少量共
    享对象，可以降低运行web应用程序所需的资源数量。

    13.1  享元的结构

        刚接触享元模式的时候其工作机制可能很难理解。我们先对其结构作一鸟瞰，然后再详细讲解各个部分。

    13.2  示例：汽车登记
        汽车作为一个对象，包含详细信息。

        /* Car class, un-optimized. */

        var Car = function(make, model, year, owner, tag, renewDate) {
          this.make      = make;
          this.model     = model;
          this.year      = year;
          this.owner     = owner;
          this.tag       = tag;
          this.renewDate = renewDate;
        };

        Car.prototype = {
          getMake: function() {
            return this.make;
          },
          getModel: function() {
            return this.model;
          },
          getYear: function() {
            return this.year;
          },

          transferOwnership: function(newOwner, newTag, newRenewDate) {
            this.owner = newOwner;
            this.tag = newTag;
            this.renewDate = newRenewDate;
          },
          renewRegistration: function(newRenewDate) {
            this.renewDate = newRenewDate;
          },
          isRegistration: function() {
            var today = new Date();
            return today.getTime() < Date.parse(this.renewDate);
          }
        };

        //这个系统最初表现不错，可是随着城市人口的增长，汽车对象不断耗尽了资源，要想优化这个系统，可以采用享元模式
        //减少所需对象的数目，优化工作的第一步就是把内在状态与外在状态区分开来。

    13.2.1  内在状态和外在状态
    
        将对象数据划分为内在和外在状态的过程有一定的随意性。既要维持每个对象的模块性，又想尽可能的多的数据作为外
        在数据处理，划分依据多少有些主观性。在本例中，车的自然属性属于内在数据，而所有权属性属于外在数据。这意味
        着对于品牌、型号和出厂日期的每一种组合，只需要一个汽车对象就行。这个数目还是不少的，不过与之前相比已经少
        了几个数量级。每个品牌-型号-出厂日期对应的实例将被所有该类汽车车主共享。下面是新版Car类的代码

        /* Car class， optimized as flyweight. */
        var Car = function(make, model, year) {
          this.make  = make;
          this.model = model;
          this.year  = year;
        };

        Car.prototype = {
          getMake: function() {
            return this.make;
          },
          getModel: function() {
            return this.model;
          },
          getYear: function() {
            return this.year;
          }
        };
        //上述代码删除了所有外在数据，所有的处理登记事宜的方法被转移到一个管理器对象中（不过，也可以将这些方法
        保留，并为其增加对应于各种外在数据的参数），因为现在对象的数据已经被分为两大部分，所以必须由工厂来实例
        化它。

    13.2.2  用工厂进行实例化
        这个工厂很简单，它会检查之前是否已经创建对应于指定品牌-型号-出厂日期组合的汽车，如果存在这样的汽车那么就
        返回，否则就创建一辆新车，并把他保存起来供以后使用。这就确保了对应于每个唯一的内在状态，只会创建一个实
        例：
        /* CarFactory singleton. */

        var CarFactory = (function() {

          return {
            createCar: function(make, model, year) {
              //check to see if this particular combination has been created before.
              if ( createCars[make + '-' + model + '-' + year] ) {
                return createdCars[make + '-' + model + '-' + year];
              }
              //Otherwise create a new instance and save it.
              else {
                var car = new Car(make, model, year);
                createdCars[make + '-' + model + '-' +year] = car;
                return car;
              }
            }
          }; //end of return {}

        })();

    13.2.3  封装在管理器中的外在状态
        要完成这种优化还需要一个对象，所那些从Car对象中删除的数据必须有个保存地点，我们用一个单体来做这
        些数据的管理器。原先的每一个Car对象现在那部分被分割为外在数据及其所属的共享汽车对象的引用这样两部
        分。Car对象与车主数据的组合成为汽车记录(car record)。管理器存储着这两方面的信息它还包含着从原来的
        Car类删除的方法：
        /* CarRecordManager singleton. */

        var CarRecordManager = (function() {

          var carRecordDatabase = {};

          return {
            //Add a new car record into the city's system.
            addCarRecord: function(make, model, year, owner, tag, renewDate) {
              var car = CarFactory.createCar(make, model, year);
              carRecordDatabase[tag] = {
                owner: owner,
                renewDate: renewDate,
                car: car
              };
            },

            //Methods previously contained in the Car class.
            transferOwnership: function(tag, newOwner, newTag, newRenewDate) {
              var record = carRecordDatabase[tag];
              record.owner = newOwner;
              record.tag = newTag;
              record.renewDate = newRenewDate;
            },
            renewRegistration: function(tag, newRenewDate) {
              carRecondDatebase[tag].renewDate = newRenewDate;
            },
            isRegistrationCurrent: function(tag) {
              var today = new Date();
              return today.getTime() < Date.parse(carRecordDatabase[tag].renewDate);
            }
          }; //end of return {}

        })(); 

        //从Car类剥离的所有数据现在都保存在CarRecordManager这个单体中的私用属性carRecordDatabase中。这个
        carRecordDatabase对象要比以前的一大批对象高效很多。那些处理所有权事宜的方法现在也被封装在这个单体中，
        因此它们处理的都是外在数据。
            可以看出，这种优化是以复杂性为代价的。原先有的只是一个类，而现在却变成了一个类和两个单体，把
        一个对象的数据保存在两个不同的地方这种做法也有点令人困惑。但与所解决的性能问题相比，这两点都只是小问
        题。如果运用得当，那么享元模式能够显著的提升程序的性能。

    13.3  管理外在状态

        管理享元对象的外在数据有许多种不同的方法没使用管理器对象是一种常见做法，这种对象有一个集中管理的数据
        （centralized database），用于存放外在状态及其所属的享元对象。
        另一种管理方案是组合模式，可以用对象自身的层次体系来保存信息，而不需要另外使用一个集中管理的数据库。
        组合对象的叶结点全都是享元对象，这样一来这些享元对象就可以在组合对象层次体系中的多个地方被共享。
        对于大型系统的对象层次这非常有用，因为同样的数据用这种方案来表示时所需要的对象的数量要少得多。

    13.4  示例：Web日历

        为了演示用组合对象来保存外在状态的具体做法，下面我们要创建一个Web日历。首先实现的是一个未经优化、未使用享
        元版本。这是一个大型的组合对象，位于最顶层的是代表年份的组合对象。它封装着代表月份的组合对象，而后者又封装
        了代表日期的叶对象。这是一个简单的例子，它会按顺序显示每月中的每一天，还会按顺序显示一年中的各个月：

        见dp_demo13_4 

    13.4.1  把日期对象转化为享元
    
        把CalendarDay对象转化为享元对象的过程很简单。首先，修改CalendarDay类本身，除去其中保存的所有数据，让这些数
        据（日期和父元素）成为外在数据：
        /* CalendarDay class, a flyweight leaf. */

        var CalendarDay = function() {}; //implements CalendarItem
        CalendarDay.prototype = {
          display: function(date, parent) {
            var element = document.createElement('div');
            parent.appendChild(element);
            element.innerHTML = date;
          } 
        };    

        接下来，创建日期对象的单个例子。所有CalendarMonth对象中都要使用这个实例。这里本来也可以像第一个示例那样使用
        工厂来创建该类的实例，不过，因为这个类只需要创建一个实例，所以直接实例化它就行：
        /* Single instance of CalendarDay. */

        var calendarDay = new CalendarDay();

        /* CalendarMonth class, a composite. */

        var CalendarMonth = function(monthNum, numDays, parent) { //implements CalendarItem
          this.monthNum = monthNum;
          this.element = document.createElement('div');
          this.element.style.display = 'none';
          parent.appendChild(this.element);

          this.days = [];
          for ( var i = 0, len = numDays; i < len; i++ ) {
            this.days[i] = calendarDays;
          }
        };
        CalendarMonth.prototype = {
          display: function() {
            for ( var i = 0, len = this.days.length; i < len; i++ ) {
              this.days[i],display(i, this.element);
            }
            this.element.style.display = 'block';
          }
        };

    13.4.2  外在数据保存在哪里
    
        //...

    13.5  示例：工具提示对象
    
        /* Tooltip class, un-optimized. */ 

        var Tooltip = function(targetElement, text) {
          this.target = target;
          this.text = text;
          this.delayTimeout = null;
          this.delay = 1500; //毫秒

          //Create the HTML.
          this.element = document.createElement('div');
          this.element.style.display = 'none';
          this.element.style.position = 'absolute';
          this.element.className = 'tooltip';
          document.getElementsByTagName('body')[0].appendChild(this.element);
          this.element.innerHTML = this.text;

          //Attach the events.
          var that = this; //Correcting the scope.
          addEvent(this.target, 'mouseover', function(e) { that.startDelay(e); } )
          addEvent(this.target, 'mouseout', function(e) { that.hide(); } )
        };
        Tooltip.prototype = {
          startDelay: function(e, text) {
            if ( this.delayTimeout == null ) {
              var that = this;
              var x = e.clientX;
              var y = e.clientY;
              this.delayTimeout = setTimeout(function() {
                that.show(x, y, text);
              }, this.delay);
            }
          },
          show: function(x, y, text) {
            clearTimeout(this.delayTimeout);
            this.delayTimeout = null;
            this.element.innerHTML = text;
            this.element.style.left = x + 'px';
            this.element.style.top = (y + 20) + 'px';
            this.element.style.display = 'block';
          },
          hide: function() {
            clearTimeout(this.delayTimeout);
            this.delayTimeout = null;
            this.element.style.display = 'none';
          }
        };

        /*
          上述的Tooltip类删除了原先的构造函数的所有的参数以及注册的时间处理器的代码。而startDelay和show方法则各自增
          加了一个新的参数，这样一来，要显示的文字就可以作为外在数据传给它们。下一步是创建用作工厂和管理器的那个单
          体。我们把Tooltip类的声明放在TooltipManager这个单体中，这样它就不能在别的地方被实例化：
          /* TooltipManager singleton, a flyweight factory and manager. */

          var TooltipManager = (function() {
            var storedInstance = null;

            /* Tooltip class, as a flyweight. */

            var Tooltip = function() {
              //...
            };
            Tooltip.prototype = {
              //...
            };

            return {
              addTooltip: function(targetElement, text) {
                //GET the tooltip object.
                var tt = this.getTooltip();
                //Attach the events.
                addEvent(targetElement, 'mouseover', function(e) { tt.startDalay(e.text); } )
                addEvent(targetElement, 'mouseout', function(e) { tt.hide(); } )
              },
              getTooltip: function() {
                if ( storedInstance == null ) {
                  storedInstance = new Tooltip();
                }
                return storedInstance;
              }
            };
          })();
          /*
              这个单体有两个方法，分别体现了它的两种角色。getTooltip是工厂方法，它与你之前看待过的其他享元的生成
              方法差不多。addTooltip则是管理器方法，它先获取一个Tooltip对象，然后分别把两个匿名函数注册为目标元素
              的mouseover和mouseout事件监听器。这个例子用不着创建中心数据库，因为那两个匿名函数中生成的闭包已经保
              存了外在数据。现在创建工具提示的代码看起来与之前的有点不一样，在这里应该调用addTooltip方法，而不是实
              例化Tooltip：
              /* Tooltip Usage. */
              TooltipManager.addTooltip($('#link-id'), 'found&lost site');

              PS: iframe垫片技术：
              IE5.5之前的iframe，IE7之前的select是一种window control组件，拥有者一个特定，就是不会被任何HTML元素
              遮挡，即使别的元素定位到其上。但是IE5.5时候，iframe改邪归正，还拥有了新特定，即自己不再是窗口控件
              window control，而且自己可以挡住窗口控件，因此，IE5.5， IE6中普通HTML挡不住的窗口控件可以用iframe
              遮挡且在再挡住iframe，看起来就好像是普通元素直接遮挡了窗口控件，此特定就叫做iframe垫片技术.
          */       

    13.6  保存实例供以后重用

        模式对话框是享元模式的另一个使用场合，与工具提示一样，对话框对象也封装着数据和HTML内容，不过，后者包含的DOM
        更多，因此尽可能的减少实例化更显得重要。问题在于网页上可能会不止出现一个对话框。实际上，你无法确切知道究竟
        需要多少对话框。既然如此，那又怎么能得知需要用到多少实例那？
            因为运行期间需要用到的实例的确切数目无法在开发期间确定，所以不能对实例的个数加以限制，而只能是要用多少
        就创建多少，然后把它们保存起来供以后使用。这样就不用承受其创建过程中的开销，而且所创建的实例的数目也刚好满
        足要求。
            在这个示例中，DialogBox对象的实现细节并不重要，你只需要知道，他是资源密集型的对象，应该尽量少实例化。
        该类的基本实现框架以及它的实现接口如下所示：

        /* DisplayModule interface. */

        var DisplayModule = new Interface('DisplayModule', ['show', 'hide', 'state']);

        /* DialogBox class. */

        var DialogBox = function() { //implements DisplayModule
          //...
        };
        DialogBox.prototype = {
          show: function(header, body, footer) {
            //...
          },
          hide: function() {
            //...
          },
          state: function() {
            //...return visible or hidden
          } 
        }; 

        /* DialogBoxManager singleton. */

        var DialogBoxManager = (function() {
          var created = []; //Stores created instances.

          return {
            displayDialogBox: function(header, body, footer) {
              //...
            },
            createDialogBox: function() { //Factory method.
              //...
            },
            numberInUse: function() {
              //...
            }
          };
        })();

        /*
           这个管理器把已经创建出来的对话框对象保存在数组created中，以便于重用。numberInUse方法用于获取现有的
           DialogBox对象中当前正在被使用的对象的个数，它通过检查DialogBox对象的状态判断其是否正在被使用。
           displaDialogBox方法会先检查这个数字是否不小于数组的长度，并且只有在不能重复重用现有实例的情况下才创建
           新实例。
           中心思想：资源密集型对象剥离重用，就像SQL线程池，仅当现有的连接都耗尽才创建新连接。
        */
    
    13.8  享元优化的步骤

        （1）  剥离外在数据，由管理器提供。
        （2）  创建一个用于控制该类的实例化的工厂，这个工厂应该掌握该类所有已经创建粗俩的独一无二的实例。
        （3）  创建一个用来保存外部数据的管理器。

--- 2014 06 23 - 2014 06 27 ---
第十四章 : 代理模式

    本章讨论的是代理模式，代理（proxy）是一个对象，它可以用来控制对另一个对象的访问。它与另外那个对象实现了同样的
    接口，并且会把任何方调用传递给那个对象。另外那个对象通常称为本体(real subject)。代理可以代替其本体被实例化，并
    使其可被远程访问。它还可以把本体的实例化推迟到真正需要的时候，对于实例化比较费时的本体，或者因尺寸较大以至于不
    用时不适宜保存在内存的本体，这特别有用。在处理那些需要较长时间才能把数据载入用户界面的类时，代理也大有裨益。

    14.1  代理的结构

        代理模式最基本的形式是对访问进行控制。代理对象和另一个对象（本体）实现的是同样的接口。实际上工作还是本体在
    做，它才是负责执行所分派的任务的那个对象或类。代理对象所做的不外乎就是对本体的访问。要注意，代理对象并不会在另
    一个对象的基础上添加方法或修改其方法（就像装饰者那样），也不会简化那个对象的接口（就像门面模式那样）。它实现了
    接口与本体完全相同，所有对它的方法调用都会被传递给本体。

    14.1.1  代理如何控制本体的访问

    （1）不实现任何访问控制的代理

        /* From chapter 3. */

        var Publication = new Interface('Publication', ['getIsbn, 'setIsbn, 'getTitle', 'setTitle', 'getAuthor',
            'setAuthor', 'display']);
        var Book = function(isbn, title, author) { //...}  //implements Publication.
        
        /* Library interface. */

        var Library = new Intreface('Library', ['findBooks', 'checkoutBooks', 'returnBook']);

        /* PublicLibrary class. */

        var PublicLibrary = function(books) { //implements Library.
          this.catalog = {};
          for ( var i = 0, len = books.length; i < len; i++ ) {
            this.catalog[ books[i].getIsbn() ] = { book: books[i], available: true };
          }
        };
        PublicLibrary.prototype = {
          findBooks: function(searchString) {
            var results = [];
            for ( var isbn in this.catalog ) {
              if ( !this.catalog.hasOwnProperty(isbn) ) continue;
              if ( searchString.match( this.catalog[isbn].getTitle() ) || 
                   searchString.match( this.catalog[isbn].getAuthor() ) ) {
                     results.push(this.catalog[isbn]);
                   } 
            }
            return results;
          },
          checkoutBook: function(book) {
            var isbn = book.getIsbn();
            if ( this.catalog[isbn] ) {

              if ( this.catalog[isbn].available ) {
                this.catalog[isbn].available = false;
                return this.catalog[isbn];
              } else {
                throw new Error(' PublicLibrary: book ' + book.getTitle() + ' is not currently available. ');
              }

            } else {
              throw new Error(' PublicLibrary: book ' + book.getTitle() + ' is not found. ');
            }
          }
        };

        /*
         *  这个类非常简单。它可以用来查书，借书和还书。下面是一个没有实现任何访问控制的PublicLibrary类的代理
        */   

        /* PublicLibraryProxy class, a useless proxy. */

        var PublicLibraryProxy = function(catalog) { //implements Library
          this.library = new PublicLibrary(catalog);
        };

        PublicLibraryProxy.prototype = {
          findBooks: function(searchString) {
            return this.library.findBooks(searchString);
          },
          checkoutBook: function(book) {
            return this.library.checkoutBook(book);
          },
          returnBook: function(book) {
            return this.library.returnBook(book);
          }
        };

    14.1.2  虚拟代理、远程代理和保护代理

        对于JavaScript程序员来说，虚拟代理可能是最有用的代理类型。下面我们简要介绍一下其他代理类型，并说明为什么
        它们对JavaScript编程不那么适用。
            远程代理(remote proxy)用于访问位于另一个环境中的对象。在Java中，这意味着另一个虚拟机中的对象，或者是
        地球另一端的某台计算机中的对象。远程对象一般都长期存在，任何时候都可以从任何其他环境中进行访问。这种类型
        的代理很难照搬到JavaScript中。其原因是首先，通常JavaScript运行时环境不可能长期存在。大多数JavaScript环境
        委身于Web了浏览器，因此随着用户的网上冲浪活动，通常没过几分钟，运行时环境就会重新加载一次或卸载一次。第二
        在JavaScript中无法建立到另一个运行时环境的套接字连接以访问其变量空间，即便它能长期存在。因此最接近的只是用
        JSON对方法调用进行序列化，然后用Ajax技术将结果发送给某个资源。
            远程代理的一种更有可能的用途是控制对其他语言的本体的访问。这种本体可能是一个Web服务器资源，也可能是PHP
        对象。在此情况下，很难说你所用的究竟是什么模式。它既可以被视作适配器，也可以被视作远程代理，因此这是一个灰
        色地带，所以有必要为这种模式确定一个名称。我们决定选择远程代理这个名称，原因在于这个名称更具有说明性，也更
        准确，而且这里所说的模式更接近于代理模式而不是适配器模式。第一个例子中对此有更多的讨论。
            保护代理也无法照搬到JavaScript中，它通常用于根据用户的身区别对特定的方法进行访问，JavaScript中无法判断
        调用方法的客户是什么类型，因此也就不可能实现这种模式。
            由于以上原因，本章集中讨论的是虚拟代理和远程代理。

    14.1.3  代理模式和装饰者模式的比较   

            代理在许多方面都很像装饰者。装饰者和虚拟代理都需要对对象进行包装，都要实现同样的接口，而且都把方法的调
        用传递给被包装对象。那么二者究竟有什么区别那。
            （1）代理模式不修改调用的方法
            （2）实例化过程一般包装在代理内部
            （3）代理一个只可以使用一个

    14.2  代理模式的适用场合

            虚拟代理：是一个优化模式，提供了一种创建开销昂贵的对象的资源访问控制。一些类并不需要实例化后立即使用，
        那么就推迟到真正需要使用的时候再实例化。代理还可以在设置的进行过程中提供如："正在加载..."，这样的消息，避免
        用户面对空白页面发呆。
            远程代理：是一个结构模式，访问某种远程资源最好用一个对象来包装它。如果它实现了所有远程资源的所有方法，
        它就是个远程代理，如果会在运行期间添加一些方法，那就是装饰者，如果简化了该资源（或多个远程资源）的接口，那
        它就是门面。远程代理提供访问位于其他环境中的资源的原声JavaScript API。
            总而言之，如果有些类或对象的创建开销较大，而且不需要在实例化完成后立即访问其数据，那么应该使用虚拟代理
        如果你有一种远程资源，并且要为该资源提供的所有功能实现对象的方法，那么应该使用远程代理。
        
    14.3  示例：网页统计

        见dp_demo14_3

    14.4  包装Web服务的通用模式

            我们可以从上面的例子提炼出一个更加通用的Web服务包装模式。尽管在设计这种代理时的具体实现细节会因为Web服
        务类型的而异，但是这个通用模式可以提供一个一般性的框架。由于JavaScript的同源限制，Web服务代理所包装的服务必
        须部署在一个使用代理的网页所造的域中。这里使用的不是一个单体，而是一个拥有构造函数的普通类，以便进行扩展：

        见dp_demo14_4

    14.5  示例：目录查找
    
            这次的任务是为公司的网站的主页添加一个可搜索的员工目录。它应该模仿实际的员工花名册中的页面，从A开始，
        显示其姓氏以特定字母开头的所有员工。由于这个网页的访问量很大，所以这个解决方案必须尽量节省带宽。我们不希
        望这个小小的特性拖累整个页面。
            因为在这个问题中网页的大小很重要，所以我们决定只为那些需要查看员工资料的用户加载这种数据（要知道数据
        量巨大）。这样一来，那些不关心这种信息的用户就不用下载额外的数据。这是虚拟代理可以大显身手的地方，因为它
        能够把需要占用大量贷款的资源推迟到需要的时候再加载。我们还要为数据载入时提供必要的信息，以免用户面对空白
        页面时不知道网站出了什么问题。这种任务非常适合使用虚拟代理。
            首先要做的就是创建代理的呢个本类。它负责获取员工的数据并生成用于网页显示的这些数据的HTML内容，其显示
        格式类似于电话号码簿：
        
        见dp_demo14_5   

    14.6  创建虚拟代理的通用模式

        见dp_demo14_6

    小节:代理模式的利弊
    
        自己领悟。。。

--- 2014 06 28 - 2014 06 29, 2014 0701 - 2014 0702 2014 0830 - 2014 0901 ---          
第十五章 : 观察者模式

    在事件驱动的环境中，比如浏览器这种持续寻求用户关注的环境中，观察者模式（又名发布者-订阅者模式）是一种管理人与
    其任务之间的关系（确切地讲，是对象及其行为的状态之间的关系）的得力工具。用JavaScript的话来说，这种模式的实质
    就是你可以对程序中某个对象的状态进行观察，并且在其发生改变时能够得到通知。
        观察者模式中存在两个角色：观察者和被观察者。本书一般倾向于称其为发布者-订阅者模式。这种模式在JavaScript中
    有几种不同的实现方式，本章将对其中的一些实现方式进行考查。不过我们首先说明一下发布者-订阅者这两种角色。下一节
    的例子以报业为例说明了观察者模式的工作方式。

    15.1  示例：报纸的投送

        在报纸业中，发行和订阅的顺利进行进行依赖于一些关键的角色和行为。首先时读者。他们都是订阅者（subscriber）
        ，是与你我一样的人。我们消费数据并且根据数据读到的消息做出反应。我们可以选择自己的居住地点，让报社把报纸
        送到自己家里来，这个活动中的另一个角色就是发行方（publisher）。他们负责出版诸如xxx的报纸。

        多对多的关系需要我们抽象的更好（一个读者可能订阅许多种报纸，而一家报社可能向许多消费者推送报纸）

    15.1  推与拉的比较
    
        对于报社来说只为给几个订阅者投送报纸就满天下的跑就不划算的，而从纽约去旧金山取报纸更是天方夜谭，所以一
        种主动推送报纸和自主取报更为合理。

    15.1.2  模式的实践
    
        在JavaScript中有多种方法可以实现发布者-订阅者模式。在展示那些示例之前，我们先确保各种角色的扮演者
        （对象）及其行为（方法）都已就绪。
            订阅者可以订阅和退订，他们还要接收，"由人投递"和"自己去取"都可以。
            发布者负责投送，他们可以在"送出"和"由人取"之间进行选择。

        下面是一个展示发布者-订阅者模式之间的互动过程的高层示例，他是Sells方法的一个示范，这种技术类似于
        驱动测试开发（TDD），不过它要先写实现代码，就像API已经写好了一样，为了让这些代码成为可以运转的真正
        实现，程序员需要完成各种该做的工作，API由此形成：

        /*
         *  origin: http://pluralsight.com/blogs/archive/2007/01/24/45864.aspx
        **/            

        /*
         *  Publisher - subscriber 
        **/

        var Publisher = new Observable;

        var Subscriber = function(news) {
          //news delivered directly to my front porch
        };
        Publisher.subscriberCushomer(Subscriber);

        /*
         *  Deliver a paper:
         *  sends out news to all subscribers.
        **/

        Publisher.deliver('extre, extre, read all about it');

        /*
         *  That customer forgot to pay his bill.
        **/
        Publisher.unSubscribeCustomer(Subscriber);
        //这个模型发布者处于明显的主导地位，它们负责登记其顾客，而且有权停止为其投送。最后新的报纸出版后它们将
        //会为其投送给顾客

        /*
         *  Newspaper Vendors
         *  setup as new Publisher object
        **/

        var NewYorkTimes = new Publisher();
        var AustinHerald = new Publisher();
        var SfChronicle = new Publisher();

        /*
          *  People who like to read
          *  (Subscribers)
          *
          *  Each subscriber is set up as a callback method.
          *  They all inherit from Function prototype Object. 
        */

        var Joe = function(from) {
          console.log('Delivery from ' + from + 'to Lindsay');
        };
        var Quadaras = function(from) {
          console.log('Delivery from ' + from + 'to Quadaras');
        };

        /*
          *  Here we allow them to subscribe to newspapers
          *  which are the Publisher objects.
          *  In this case Joe subscribes to NY Times
          *  the Chronicle.Lindsay subscribes to NY Times
          *  Austin Herald and Chronicle.And the Quadaras
          *  respectfully subscribe to the Herald and the Chronicle 
        */

        Joe.
          subscribe(NewYorkTimes).
          subscribe(SfChronicle);

        Lindsay.
          subscribe(AustinHerald).
          subscribe(SfChronicle).
          subscribe(NewYorkTimes);  

        /*
          *  Then at any given time in our application, our publishers can send
          *  off data for the subscribers to consume and react to.
        */
        NewYorkTimes.
          deliver('Here is your paper!Directly from the Big apple.');
        AustinHerald.
          deliver('News').
          deliver('Reviews').
          deliver('Coupons');
        SfChronicle.
          deliver('The werther is still chilly').
          deliver('Hi Mon, I\'m writing a book');

        /*
         *  这个例子中，发布者的创建方式和订阅者接受数据的方式没有多少变化，但拥有订阅和退订权的一方变成了订阅者
         *  当然，负责发送数据的一方还是发布者一方。
        **/      

    15.2  构建观察者API
        在明确了观察者模式中的核心成员后，现在可以着手构建其API了。首先，我们需要一个发布者的构造函数，它为该类实
        例定义了一个类型的数组的属性，用来保存订阅者的引用：
        function Publisher() {
          this.subscribers = [];
        }    

    15.2.1  投送方法
    
        所有的Publisher实例都应该能够投送数据。只要把deliver方法添加到Publisher的prototype中，他能够被所有
        Publisher对象共享：
        Publisher.prototype.deliver = function() {
          this.subscribers.forEach(
            function(fn) {
              fn(data);
            }
          );
          return this;
        };    

        这个方法用JavaScript1.6种的新增的forEach方法逐一处理每一个订阅者，forEach方法会对一个进行从头到尾的遍历
        把每一个索引和整个数组提供一个回调方法，订阅者数组中的没跟“针”都是回调函数，比如Joe。
        deliver方法把this用作返回值，因此可以对该方法进行链式调用，以连续不断地投送数据

    15.2.2  订阅方法

        下一步是给予订阅者订阅的能力：
        Function.prototype.subscribe = function(publisher) {
          var that = this;
          var alreadyExists = publisher.subscribers.some( //有一个返回true则返回true
            function(el) {
              return el === that;
            }
          );
          if ( !alreadyExists ) {
            publisher.subscribers.push(this);
          }
          return this; //支持方法链式调用
        };

    15.2.3  退订方法
    
        //unsubscribe方法可供订阅者用来停止对指定发布者的观察
        Function.prototype.unsubscribe = function(publisher) {
          var that = this;
          publisher.subscribers = publisher.subscribers.filter(
            function(el) {
              return el !== that;
            }
          );
          return this;
        };

        var observerObject = function(data) {
          //process data
          console.log(data);
          //unsubscribe from this publisher
          arguments.callee.unsubscribe(publisherObject);
        };

        observerObject.subscribe(publisherObject); 

    15.3  现实生活中的观察者  

        在现实生活中的观察者对于那些由许多JavaScript程序员合作开发的大型程序特别有用。它可以提高API的灵活性，使并
        行开发的多个实现能够彼此独立的进行修改。作为开发人员，你可以对自己的应用程序中什么是“令人感兴趣的时刻”做出
        决定。你能监听的不再只是click，load，blur等浏览器事件。在富用户界面（rich UI）应用程序中，drag、drop、
        moved，tabSwitch等等都可能令人感兴趣。他们都是在普通浏览器事件的基础上抽象出来的可观察事件，可由发布者对象
        对其监听者广播。

    15.4  示例：动画
    
        动画是在应用程序中实现可观察对象的一个很好的起点。眨眼睛你就能想出至少三个可以观察的时刻：开始，结束和进行中
        在本例中，我们将分别称之为onStart,onComplete和onTween.下面的代码演示了用前面编写的Publisher工具实现这些事件
        的过程：

        //Publisher API
        var Animation = function(o) {
          this.onStart = new Publisher,
          this.onComplete = new Publisher,
          this.onTween = new Publisher;
        };
        Animation.
          method('fly', function() {
            //begin animation
            this.onStart.deliver();
            for( ... ) { //loop through frames
                //deliver frame number
                this.onTween.deliver(i);
            }
            //end animation.
            this.onComplete.deliver();
        });    

        //setup an account with the animation manager
        var Superman = new Animation( { //cfg } );

        //Begin implementing subscribers
        var putOnCape = function(i) {};
        var takeOffCape = function() {};

        putOnCape.subscribe(Superman.onStart);
        takeOffCape.subscribe(Superman.onComplete);

        //fly can be called anywhere
        Superman.fly();
        //for instance:
        addEvent(element, 'click', function() {
          Superman.fly();
        });


    15.5  事件监听器也是观察者

        //example using listeners
        var element = $('example');
        var fn1 = function(e) {
          //handle click
        };
        var fn2 = function(e) {
          //do other stuff with click
        };

        addEvent(element, 'click', fn1);  
        addEvent(element, 'click', fn2);

        //example using handlers
        var element = document.getElementById('b');
        var fn1 = function(e) {
          //handle click
        };
        var fn2 = function(e) { 
          //do other stuff with click
        };

        element.onclick = fn1;  
        element.onclick = fn2; //only exec fn2, fn1 is just replace by fn2  

    15.6  观察者模式的适用场合
    
        如果希望把人的行为和应用程序的行为分开，那么观察者模式正适合于这种场合。最好不要实现一些与用户操作及浏览器提供的
        方法有关的基本DOM事件。对于那些只关心动画的开始，或者错别字的发现（在拼写检查应用程序中）的程序员而言，那些事件提
        供不了什么有用的信息。
        举例来说，用户点击导航系统的一个标签（tab）时，会打开一个包含着更多相关信息的菜单。当然你可以直接监听这个click事件
        不过需要知道监听的是哪个元素。这样做的另一个弊端是你的实现与click事件直接绑定在了一起。比监听click事件更好的方式是
        创建一个onTabChange对象，并且在特定事件发生时通知所有观察者。如果菜单改为在鼠标指向标签时或者标签处于焦点之下时打开，
        那么这个onTabChange对象会替你处理这种改变（及改变此对象监听方法即可）

    15.7  观察者模式之利
    
        观察者模式是开发基于行为的大型应用程序的有力手段。在一次浏览器会话期间会发生大量事件，你可以消减给事件注册监听器的
        数量，让可观察对象借助一个事件监听器替你处理各种行为并将信息委托（delegate）给它的所有订阅者，从而降低内存消耗和提
        高互动性。这样一来，就不用没完没了的为同样的元素添加新的事件监听器，这有利于减少系统的开销并提高程序的可维护性。

    15.8  弊端
    
        初次加载开销大，可通过惰性加载优化，即推迟到需要发送事件通知的时候。

--- 2014 09 01 - 2014 09 03 ---
第十六章 : 命令模式

    本章研究的是一种封装方法调用的方式。命令模式与普通函数有所不同。它可以用来对方法调用进行参数化处理和传达，经这样处理过的
    方法






        

        



        


    





      

    






        



        




















         


    

    
    




