@include ch07\ch08\ch09

--- 2014 04 14 - 2014 04 15, 2014 04 23 - 2014 04 24，2014 04 30  2014 0504 - 2014 0505 ---
第七章 : 工厂模式

    前言：
    一个类或者对象中往往包含别的对象。在创建这种成员对象时，你可能习惯于使用常规方法，即用new关键字和类构造函数
    问题在于这会导致相关的两个类之间产生依赖性，本章将讲述一个有助于消除这两个类之间依赖性的模式，它使用一个方法
    来决定究竟要实例化哪个具体的类，我们既要讨论简单的工厂模式，也要讨论更复杂的工厂模式，前者另外使用一个类，
    通常是单体来生成实例，而后者则使用子类来决定一个成员变量应该是哪个具体的类的实例。

    7.1  简单工厂

    /* BicycleShop class */

    var BicycleShop = function() {};
    BicycleShop.prototype = {
        sellBicycle : function(model) {
            var bicycle;

            switch(model) {
                case 'The Speedster':
                    bicycle = new Speedster();
                    break;
                case 'The Lowrider' :
                    bicycle = new Lowrider();
                    break;
                case 'The Comfort Cruiser' :
                default :
                    bicycle = new ComfortCruiser();    
            }
            Interface.ensureImplements(bicycle, Bicycle);
            bicycle.assembel();
            bicycle.wash();

            return bicycle;
        }
    };

    //见dp_demo7_1, dp_demo7_2

    7.2  工厂模式

    真正的工厂模式与简单工厂模式的区别在于，他不是使用另外一个类或对象来创建自行车（就像前面的例子所做的那样），
    而是使用一个子类。按照正式定义，工厂是一个将其成员对象的实例化推迟到子类中进行的类。我们还是以BicycleShop为
    例来说明简单工厂和工厂模式之间的差别。
        我们打算让各个自行车商店自行决定从哪个厂家进货，出于这个原因，单单一个BicycleFactory对象将无法提供需要的
    所有自行车实例。我们可以把BicycleShop设计为抽象类，让子类根据各自进货渠道实现其createBicycle方法：

    见dp_demo7_3

        因为两个生产厂家生产的自行车款式完全相同，所以顾客买车时可以不用关心车究竟是哪家生产的。要是他们只想要
    Acme生产的自行车，他们可以去Acme专卖店去买。
        增加对其他生产厂家的支持很简单，只要在创建一个BicycleShop的子类并进行重定义其createBicycle工厂方法即可
    我们可以对其各个子类进行修改，以支持相关厂家的其他型号的产品。这是工厂模式的最重要的特点，对Bicycle进行一般
    性操作的代码可以写在父类里，而具体的Bicycle对象进行实例化的工作则留到子类中，一般性的代码被集中在一个位置，
    而个体性的代码则被封装在子类中。

    7.3  工厂模式的适用场合
        创建新对象最简单的办法就是使用new关键字和具体类，只有在某些场合下，创建和维护对象工厂所带来的额外复杂性
    才是物有所值的，本节概括了这些场合。
    （1）
        动态实现 : 运行时多态
    （2）
        节省设置开销
        如果对象需要进行复杂并且彼此相关的设置，那么使用工厂模式可以减少每种对象所需要的代码量。如果这种设置只需
    要为特定的类型的所有实例执行一次即可，这种作用尤其突出。把这种设置代码放到类的构造器中并不是一种高效的做法，
    这是因为即使设置工作已经完成，但是每次实例化的时候这些代码还是会执行，而且这样做会把设置的代码分散到不同的类
    中。工厂方法非常适合于这种场合。他可以实例化所有需要的对象之前一次性的进行设置，无论有多少种类被实例化，这种
    办法都可以让设置代码集中在一个地方。设置代码都放在一个地方，以后的维护也十分方便。
    
    7.4  示例： XHR工厂
        用Ajax技术发起异步的请求是现在web开发中一个常见的任务，用于发起请求的对象是某种类的实例，具体是哪种类取
    决于用户的浏览器类型，如果代码中多次用到Ajax，那么明智的做法就是把创建这种对象的代码提取到一个类中，并创建
    一个包装器来包装实际发起请求时所要经历的一系列步骤，简单工厂非常适合这种场合，根据浏览器能力的不同生成一个
    XMLHttpRequest或ActiveObject实例:

    见dp_demo7_4, dp_demo7_4_1

    7.5  示例： RSS阅读器

    见dp_demo7_5  
        
    7.6  工厂模式之利
        工厂模式的主要好处在于消除对象间的耦合，通过使用工厂方法而不是new关键字及具体类，你可以把所有实例化代码
    集中在一个位置，这可以大大简化更换所有的类或运行期间动态选择所用的类工作。在派生子类时它也提供灵活性，使用工
    厂模式，你可以先创建一个抽象类的父类，然后在子类中创建工厂方法，从而把成员对象的实例化推迟到更专门的子类中进
    行。
        所有这些好处都与面向对象的两条原则有关：弱化对象见得耦合，防止代码的重复，在一个方法中进行类的实例化，可
    以消除重复性的代码，这是在用一个对接口的调用取代一个具体的实现，这些都有助于创建模块化的代码。

    7.7  工厂模式之弊
        可能有些人禁不住把工厂方当万金油，把普通的构造函数抛弃。new实例化可以让代码更清晰可读，要明确使用场合，
    切勿滥用。如果拿不定主意，可以不用，因为在重构代码时还有机会用。

--- 2014 0505 - 2014 0509 ---
第八章 : 桥接模式

    在实现API的时候，桥接模式非常有用，实际上，这也许是被用的最不够充分的模式之一。在所有模式中，这种模式最容易
    立即付诸实践。在设计一个Javascript API的时候，可以用这个模式来弱化它与使用它的类和对象之间的耦合。按GoF的定
    义，桥接模式的作用在于“将抽象与其实现隔离开来，以便二者独立变化”。这种模式对于JavaScript中常见的事件驱动的编
    程大有裨益。
    如果你刚进入JavaScript API开发的世界，那么很可能要创建许多获取(getter)、设置方法(setter)、请求方法(request)
    以及别的基于动作的方法。无论它们是用来创建Web服务API还是还是普通的取值器(accessor)方法和赋值器(mutator)方法
    在实现过程中桥接模式都有助于保持API代码的简介。

    8.1  示例 : 事件监听器
        桥接模式最常见的实际应用场合之一是事件监听器回调函数。假设有一个名叫getBeerById的API函数，它根据一个标示
    符返回有关某种啤酒的信息。那个被点击的元素很可能具有啤酒的标识符信息，它可能是作为元素自身的ID保存，也可能是
    作为别的自定义属性保存，下面是一种做法:

        addEvent(element, 'click', getBeerById);
        function getBeerById(e) {
            var id = this.id;
            asyncRequest('GET', 'beer.uri?id=' + id, function() {
                //callback response.
                console.log('Requested Beer : ' + resp.responseText);
            });
        }//局限性：只可以在浏览器模式使用，显然API不应局限如此

        function getBeerById(id, callback) {
            //Make request for beer by ID, then return the beer data
            asyncRequest('GET', 'beer.uri?id=' + id, function() {
                //callback response.
                callback(resp.responseText);
            });
        }

    8.2  桥接模式的其他例子  

        除了在事件回调函数与接口之间进行桥接外，桥接模式也可以用于连接公开的API代码和私用的实现代码。此外，它还
    可以把多个类联结在一起。从类的角度上看，这意味着把接口作为公开的代码编写，而把类的实现作为私用代码编写。
        如果公用的接口函数抽象了一些也许应该属于私用性的(尽管在此情况下，它不一定非得是私用的)较复杂的任务，那么
    可以使用桥接模式来收集某些私用性的信息。可以用一些具有特殊意义的方法作为桥梁以便访问私用变量空间，而不必冒险
    下到具体实现的浑水中。这一特例中德桥接函数又称为“特权函数”，第三章对此有详细说明。

        var Public = function() {
            var secret = 3;
            this.privilegedgedGetter = function() {
                return secret;
            };
        };
        var o = new Public();
        var data = o.privilegedGetter();

    8.3  用桥接模式联结多个类
        
        在现实生活中桥梁可以把多种事物联结起来，在JavaScript中也是如此：

        var Class1 = function(a, b, c) {
            this.a = a;
            this.b = b;
            this.c = c;
        };    
        var Class2 = function(d) {
            this.d = d;
        };
        var BridgeClass = function(a, b, c, d) {
            this.one = new Class1(a, b, c);
            this.two = new Class2(d);
        };
        //这看起来很像一个适配器

    8.4  示例 ： 构建XHR连接队列
        见dp_demo8_4

    8.5  桥接模式的适用场合
        很难想象，不使用桥接模式的事件驱动编程会是什么样子，但是JavaScript编程新手们常常沉迷于事件驱动开发的函
    数式风格，忘了编写接口---哪怕面对的是复杂的操作。判断什么地方应该使用桥接模式通常很简单。假设有如下代码：

        $('example').onclick = function() {
            new RichTextEditor();
        };
        从中你无法看出那个编辑器要显示在什么地方、他有哪些配置选项以及怎样修改它。这里的要诀就是让接口“可桥接”，
        实际上就是可配置。

    8.6  桥接模式之利
        掌握如何在软件开发中实现桥接模式，受益的不只是你，还有那些负责维护你的作品的人。把抽象与其实现隔离开，
    有助于独立地管理软件的各组成部分。Bug也因此更容易查找，而软件发生严重故障的可能性也减小了。说到底，桥接元素
    应该是粘合每一个抽象的粘合因子。

    8.7  桥接模式之弊
        在我们看来，这种模式并没有多少真正的缺点。前面讲述它的优点的时候已经提过了，它只会让API更加健壮、提高组
    件的模块化程度并促成更简洁的客户端系统实现。不过，这些益处是有代价的，比如造成性能和系统复杂性负面影响。

    8.8  小节
        用GoF的话来说，桥接模式“将抽象与实现隔离开来，以便二者独立变化”。它可以促进代码的模块化、促成更简洁的实现
    并提高抽象的灵活性。它可以用来把一组类和函数连续起来，而且提供了一种借助于特权函数访问私用数据的手段。    
             
--- 2014 0509 - 2014 0512 ---
第九章 : 组合模式

    （0）组合模式是一种专为创建web上的动态web上的动态用户界面而量身定制的模式。使用这种模式，可以用一条命令在多个
    对象上激发复杂的或递归的行为。这可以简化粘合性代码，使其更容易维护，而那些复杂行为则被委托给对象。
        组合模式为操劳过度的JavaScript程序员带来了两大好处。
    （1）你可以用同样的方法处理对象的集合与其中的特定子对象。组合对象(composite)与组成它的对象实现了同一批操
    作。对组合对象执行的这些操作将向下传递到所有的组成对象（constituent object），这样一来所有的组成对象都会执行同
    样的操作。在存在大批对象的情况下，这是一种非常有效的技术。藉此你可以不着痕迹地用一组对象替换一个对象，反之亦然
    。这有助于弱化各个对象之间的耦合。
    （2）它可以用来一批子对象组织成树形结构，并且使整棵树都可以被遍历。所有组织对象都实现了一个用来获取其子对
    象的方法。借助这个方法，你可以隐藏实现的细节并随心所欲地组织子对象。任何使用这个对象的代码都不会对其内部实现
    形成依赖。
        本章将示范在JavaScript中实现组合模式的方法，并讨论其适用场合。

    9.1  组合对象的结构

                        组合对象
                           |
        组合对象        组合对象      叶对象
           |               |
    叶对象       叶对象 叶对象       叶对象

    9.2  使用组合模式
        只有同时具备如下两个条件时才适合使用组合模式：
        （1）存在一批组织成某种层次体系的对象（具体的结构在开发期间可能无法得知）。
        （2）希望对这批对象或其中的一部分对象实施一个操作。

    组合模式擅长对大规模的对象进行操作，他专为组织这些对象并把操作从一个层次向下一个层次传递而设计。藉此你可以弱化
    对象间的耦合并可互换地使用一些类或实例。按这种模式编写的代码模块化程度更高，也更容易维护。

    9.3  示例：表单验证

    9.4  示例： 图片库

    9.5  组合模式之利
        使用组合模式，简单的操作也能产生复杂的结果。你不必编写大量手工遍历数组或其他数据结构的粘合代码，只需对最顶
    层的对象执行操作，让每一个子对象自己传递这个操作即可